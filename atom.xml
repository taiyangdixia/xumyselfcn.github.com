<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[MingYang's blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.xumingyang.cn/"/>
  <updated>2015-04-15T13:31:03.414Z</updated>
  <id>http://blog.xumingyang.cn/</id>
  
  <author>
    <name><![CDATA[MingYang]]></name>
    <email><![CDATA[xumyselfcn@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[LSM树及其应用]]></title>
    <link href="http://blog.xumingyang.cn/2015/04/15/LSM%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <id>http://blog.xumingyang.cn/2015/04/15/LSM树及其应用/</id>
    <published>2015-04-15T22:55:31.000Z</published>
    <updated>2015-04-15T13:29:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>LSM树的全称是Log Structured Merge Tree。从英文名中可以猜出来这个必然跟Log和Merge相关。具体来说：LSM树是将大量的随机写操作转换成批量的序列写，这样可以极大的提升磁盘数据的写入速度，不过会牺牲读取的效率。</p>
<blockquote>
<p>有种说法，基于LSM树实现的HBase的写性能比Mysql高了一个数量级，读性能低了一个数量级。</p>
</blockquote>
<h3 id="所谓LOG">所谓LOG</h3>
<p>对数据的修改增量保持在内存中，达到指定的大小限制后，将这些修改操作批量写入磁盘。因为这部分是在内存中操作，所以在操作前会将操作写入log文件中进行持久化，然后再执行相应的操作。</p>
<h3 id="所谓MERGE">所谓MERGE</h3>
<p>上面说到，内存中的数据达到指定的大小限制，会将其写入磁盘，就这样每次写入一部分文件进入磁盘，在读取的时候就需要执行<code>merge</code>操作，这里，在后面的介绍LevelDB中有详细的描述。</p>
<h2 id="详解，以LevelDB为例">详解，以LevelDB为例</h2>
<p>LSM树在大数据存储系统中获得了极为广泛的应用，比如BigTable中的单机数据存储引擎本质上就是LSM树，基于Flash的海量存储系统SILT也采用了LSM树，内存数据库RAMCloud同样采用了这个数据结构。除此之外，LevelDB也使用了LSM树，这里以LevelDB的LSM树结构来大致介绍其 一般实现原理，其他系统使用LSM树的方式与此类似。</p>
<p><a href="http://leveldb.org/" target="_blank" rel="external">LevelDB</a>是由谷歌公司研发的k/V数据库，LevelDB的静态结构如下图（<a href="http://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html" target="_blank" rel="external">图片源自这里</a>）：</p>
<p><img src="http://blog.xumingyang.me/imgs/leveldb-static.png" alt="LevelDB静态图"></p>
<p>构成LevelDB静态结构包括6个主要部分：</p>
<ul>
<li>（内存）MemTable</li>
<li>（内存）Immutable MemTable</li>
<li>（磁盘）Current文件</li>
<li>（磁盘）manifest文件</li>
<li>（磁盘）log文件</li>
<li>（磁盘）SSTable文件</li>
</ul>
<h3 id="插入数据时">插入数据时</h3>
<p>当应用写入一条Key：Value记录的时候，LevelDB会先往log文件里写入，成功后将记录插进MemTable文件中，这样基本就完成了写操作，因为一次写操作只涉及一次磁盘顺序写和一次内存写入，而MemTable才用了维护有序记录快速插入查找的<code>SkipList</code>数据结构。</p>
<blockquote>
<p>log文件在系统中的作用主要用于系统崩溃恢复而不丢失数据，假如没有log文件，因为写入的记录刚开始是保存在内存中的，此时如果系统崩溃，内存中的数据还没有来得及保存到磁盘，所以会丢失数据。</p>
</blockquote>
<h3 id="MemTable大小达到限定时">MemTable大小达到限定时</h3>
<p>当MemTable插入的数据占用内存到了一个界限后，需要将内存的记录导出到外存文件中，LevelDB会生成新的log文件和MemTable，原先的MemTable就成为Immutable MemTable，顾名思义，就是说这个MemTable的内容是不可更改的，只能读不能写入或删除。新来的数据被记录到新的log文件和MemTable，LevelDB后台调度会将Immutable MemTable的数据导出到磁盘，形成一个新的SSTable文件。SSTable就是由内存中的数据不断导出并进行Compaction操作后形成的，而且SSTable的所有文件是一种层级结构，第一层是Level 0 ，第二层是 Level 1 ，依次类推，层级逐渐增高，这也是称之为LevelDB的原因。</p>
<p>小节一下上面的过程：</p>
<ol>
<li>数据进入内存</li>
<li>记录log，数据插入MemTable</li>
<li>MemTable文件达到上限，变身Immutable MemTable，dump到磁盘，形成SSTable</li>
<li>生成新的MemTable，log</li>
</ol>
<h3 id="关于SSTable">关于SSTable</h3>
<p>通过上面的描述，可以知道Level 0层的SSTable是如何形成的。显然这些SSTable是（主键）有序的。其它Level的SSTable是由上一层Level里面的SSTable文件合并（多个有序文件的合并，这里使用的是多路归并算法）而成，其内部也是（主键）有序的。</p>
<p>有个值得注意的地方，level 0和其他level不一样的是：第0层的不同的SSTable之间主键范围有重复。比如该层的两个文件A和B，A的主键范围是{bar,cat}，B的主键的范围是{blue,same}，那么很有可能两个文件都存在key=”blood”的记录。对于其他的level则不会有这种情况。</p>
<p>关于SSTable这部分推荐<a href="https://www.igvita.com/2012/02/06/sstable-and-log-structured-storage-leveldb/" target="_blank" rel="external">这篇文章</a>，这里有个国人参考上篇写的<a href="http://www.cnblogs.com/fxjwind/archive/2012/08/14/2638371.html" target="_blank" rel="external">一篇文章</a>。</p>
<h3 id="Manifest文件">Manifest文件</h3>
<p>manifest里面记录了SSTable各个文件的管理信息，比如属于哪个Level，文件名称，最小key和最大key各自是多少。</p>
<p><img src="http://blog.xumingyang.me/imgs/leveldb-manifest.png" alt="LevelDB静态图"></p>
<h3 id="Current文件">Current文件</h3>
<p>记载当前的manifest文件名。因为在LevelDB运行过程中，随着Compaction的进行，SSTable文件会发生变化，会有新的文件产生，老的文件被废弃，manifest也会跟着反映这种变化，此时往往会生成新的manifest文件来记载这种变化，而Current则用来指定哪个manifest文件才是我们关心的那个。</p>
<h3 id="Compaction操作">Compaction操作</h3>
<ul>
<li>minor Compaction：当内存中的MemTable大小达到一定值时，将内容保存到磁盘中。</li>
<li>major Compaction：当某个Level下的SSTable文件树木超过一定设置值后，LevelDB会从这个Level的SSTable中选择一个文件(Level&gt;0)，将其和高一层级的Level+1的SSTable文件合并，这就是major Compaction。</li>
</ul>
<h4 id="minor_Compaction">minor Compaction</h4>
<p>当memtable数量到了一定程度会转换为immutable memtable，此时不能往其中写入记录，只能从中读取KV内容。之前介绍过，immutable memtable其实是一个多层级队列SkipList，其中的记录是根据key有序排列的。所以这个minor compaction实现起来也很简单，就是按照immutable memtable中记录由小到大遍历，并依次写入一个level 0 的新建SSTable文件中，写完后建立文件的index 数据，这样就完成了一次minor compaction。从图中也可以看出，对于被删除的记录，在minor compaction过程中并不真正删除这个记录，原因也很简单，这里只知道要删掉key记录，但是这个KV数据在哪里?那需要复杂的查找，所以在minor compaction的时候并不做删除，只是将这个key作为一个记录写入文件中，至于真正的删除操作，在以后更高层级的compaction中会去做。</p>
<h4 id="major_Compaction">major Compaction</h4>
<p>我们知道在大于0的层级中，每个SSTable文件内的Key都是由小到大有序存储的，而且不同文件之间的key范围（文件内最小key和最大key之间）不会有任何重叠。Level 0的SSTable文件有些特殊，尽管每个文件也是根据Key由小到大排列，但是因为level 0的文件是通过minor compaction直接生成的，所以任意两个level 0下的两个sstable文件可能再key范围上有重叠。所以在做major compaction的时候，对于大于level 0的层级，选择其中一个文件就行，但是对于level 0来说，指定某个文件后，本level中很可能有其他SSTable文件的key范围和这个文件有重叠，这种情况下，要找出所有有重叠的文件和level 1的文件进行合并，即level 0在进行文件选择的时候，可能会有多个文件参与major compaction。</p>
<p>levelDb在选定某个level进行compaction后，还要选择是具体哪个文件要进行compaction，levelDb在这里有个小技巧， 就是说轮流来，比如这次是文件A进行compaction，那么下次就是在key range上紧挨着文件A的文件B进行compaction，这样每个文件都会有机会轮流和高层的level 文件进行合并。</p>
<p>如果选好了level L的文件A和level L+1层的文件进行合并，那么问题又来了，应该选择level L+1哪些文件进行合并？levelDb选择L+1层中和文件A在key range上有重叠的所有文件来和文件A进行合并。</p>
<p>也就是说，选定了level L的文件A,之后在level L+1中找到了所有需要合并的文件B,C,D…..等等。剩下的问题就是具体是如何进行major 合并的？就是说给定了一系列文件，每个文件内部是key有序的，如何对这些文件进行合并，使得新生成的文件仍然Key有序，同时抛掉哪些不再有价值的KV 数据。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>张俊林《大数据日知录》第二章：大数据常用的算法和数据结构</li>
<li><a href="https://www.igvita.com/2012/02/06/sstable-and-log-structured-storage-leveldb/" target="_blank" rel="external">SSTable and Log Structured Storage: LevelDB</a>（<a href="http://www.cnblogs.com/fxjwind/archive/2012/08/14/2638371.html" target="_blank" rel="external">这里</a>有个中文的）</li>
<li><a href="http://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html" target="_blank" rel="external">LevelDB 实现原理</a>（这篇文章主要搬自<a href="http://www.samecity.com/blog/Index.asp?SortID=12" target="_blank" rel="external">levelDB日知录</a>）</li>
</ul>
<h2 id="扩展资料">扩展资料</h2>
<ul>
<li><a href="http://tech.uc.cn/?p=2592" target="_blank" rel="external">RocksDB介绍：一个比LevelDB更彪悍的引擎</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[本文主要讲述了LSM树，及基于LSM树实现的LevelDB。]]>
    
    </summary>
    
      <category term="LSM" scheme="http://blog.xumingyang.cn/tags/LSM/"/>
    
      <category term="大数据" scheme="http://blog.xumingyang.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="大数据" scheme="http://blog.xumingyang.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中一些被遗忘的数据结构]]></title>
    <link href="http://blog.xumingyang.cn/2015/04/08/Java%E4%B8%AD%E4%B8%80%E4%BA%9B%E8%A2%AB%E9%81%97%E5%BF%98%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://blog.xumingyang.cn/2015/04/08/Java中一些被遗忘的数据结构/</id>
    <published>2015-04-08T19:28:31.000Z</published>
    <updated>2015-04-15T13:30:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>这篇文章真是折磨人，从最初打算写的4个，一直增加到近10个。覆盖面太广，以后有时间把他们拆出来单独写~</p>
<h2 id="LinkedHashMap">LinkedHashMap</h2>
<p>首先看看LinkedHashMap的继承关系：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>{}
</code></pre><p>它是HashMap的子类，其内部在HashMap的基础上维护了一个双向链表，这个可以从其内部的Entry类看出：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>{
    <span class="comment">// These fields comprise the doubly linked list used for iteration.</span>
    Entry&lt;K,V&gt; before, after;
    Entry(<span class="keyword">int</span> hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) {
        <span class="keyword">super</span>(hash, key, value, next);
    }
    <span class="javadoc">/**
     * Removes this entry from the linked list.
     */</span>
    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span>() {
        before.after = after;
        after.before = before;
    }
    <span class="javadoc">/**
     * Inserts this entry before the specified existing entry in the list.
     */</span>
    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span>(Entry&lt;K,V&gt; existingEntry) {
        after  = existingEntry;
        before = existingEntry.before;
        before.after = <span class="keyword">this</span>;
        after.before = <span class="keyword">this</span>;
    }
    <span class="javadoc">/**
     * This method is invoked by the superclass whenever the value
     * of a pre-existing entry is read by Map.get or modified by Map.set.
     * If the enclosing Map is access-ordered, it moves the entry
     * to the end of the list; otherwise, it does nothing.
     * 
     * LinkedHashMap的迭代顺序是插入顺序还是访问顺序就是基于这个方法实现的。
     * 其原理是如果accessOrder为true，那么每次访问后都会把它放在链表的尾部。
     */</span>
    <span class="keyword">void</span> recordAccess(HashMap&lt;K,V&gt; m) {
        LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;
        <span class="keyword">if</span> (lm.accessOrder) {
            lm.modCount++;
            remove();
            addBefore(lm.header);
        }
    }
    <span class="keyword">void</span> recordRemoval(HashMap&lt;K,V&gt; m) {
        remove();
    }
}
</code></pre><p>这个双向链表定义了迭代顺序，迭代的时候就按照这个链表的顺序进行。但是LinkedHashMap还为大家提供了一个功能就是按照访问顺序进行迭代。在LinkedHashMap内部有个<code>accessOrder</code>属性：</p>
<pre><code>/**
 * <span class="type">The</span> iteration ordering <span class="keyword">method</span> <span class="keyword">for</span> this linked hash map: &lt;tt&gt;<span class="literal">true</span>&lt;/tt&gt;
 * <span class="keyword">for</span> access-order, &lt;tt&gt;<span class="literal">false</span>&lt;/tt&gt; <span class="keyword">for</span> insertion-order.
 *
 * @serial
 */
private final boolean accessOrder;
</code></pre><p>插入顺序、访问顺序这样说可能会有些不直观，具体大家可以看我写的一个<a href="https://github.com/xumyselfcn/sourceCode4Blog/blob/master/structure/LinkedHashMap" target="_blank" rel="external">例子</a></p>
<h2 id="TreeMap">TreeMap</h2>
<p>看看TreeMap的继承关系：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;
    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;
    <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>{}
</code></pre><ul>
<li>TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。</li>
<li>TreeMap 继承于AbstractMap，所以它是一个Map，即一个key-value集合。</li>
<li>TreeMap 实现了NavigableMap接口，意味着它支持一系列的导航方法。比如返回有序的key集合。</li>
<li>TreeMap 实现了Cloneable接口，意味着它能被克隆。</li>
<li>TreeMap 实现了java.io.Serializable接口，意味着它支持序列化。</li>
</ul>
<p>TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。</p>
<p>TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n) 。<br>另外，TreeMap是非同步的。 它的iterator方法返回的迭代器是fail-fast的。</p>
<blockquote>
<p>fail-fast机制是java集合(Collection)中的一种错误机制。在文章底部有关于该机制的扩展链接</p>
</blockquote>
<p>具体的请移步<a href="http://www.cnblogs.com/skywang12345/p/3310928.html" target="_blank" rel="external">这里</a>和<a href="http://www.cnblogs.com/chenssy/p/3746600.html" target="_blank" rel="external">这里</a>，我自认为不会比他们讲的更好了(^ ^)~</p>
<h2 id="WeakHashMap">WeakHashMap</h2>
<p>先看看WeakHashMap的继承关系：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;
    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;
    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>{}
</code></pre><p>WeakHashMap 继承于AbstractMap，实现了Map接口。</p>
<p>和HashMap一样，WeakHashMap 也是一个<strong>散列表</strong>，它存储的内容也是<strong>键值对(key-value)映射</strong>，而且键和值都可以是<strong>null</strong>。</p>
<p>不过WeakHashMap的键是<strong>“弱键”</strong>。在 WeakHashMap 中，当某个键不再正常使用时，会被从WeakHashMap中被自动移除。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。某个键被终止时，它对应的键值对也就从映射中有效地移除了。</p>
<p>这个“弱键”的原理呢？大致上就是，<strong>通过WeakReference和ReferenceQueue实现的</strong>。 WeakHashMap的key是“弱键”，即是WeakReference类型的；ReferenceQueue是一个队列，它会保存被GC回收的“弱键”。实现步骤是：</p>
<ul>
<li>新建WeakHashMap，将<strong>“键值对”</strong>添加到WeakHashMap中。<br>实际上，WeakHashMap是通过数组table保存Entry(键值对)；每一个Entry实际上是一个单向链表，即Entry是键值对链表。</li>
<li><strong>当某“弱键”不再被其它对象引用</strong>，并被<strong>GC回收</strong>时。在GC回收该“弱键”时，这个“弱键”也同时会被添加到ReferenceQueue(queue)队列中。</li>
<li>当下一次我们需要操作WeakHashMap时，会先同步table和queue。table中保存了全部的键值对，而queue中保存被GC回收的键值对；同步它们，就是<strong>删除table中被GC回收的键值对</strong>。</li>
</ul>
<p>这就是“弱键”如何被自动从WeakHashMap中删除的步骤了。</p>
<p>WeakReference是“弱键”实现的哈希表。它这个“弱键”的目的就是：实现对“键值对”的动态回收。当“弱键”不再被使用到时，GC会回收它，WeakReference也会将“弱键”对应的键值对删除。</p>
<p>“弱键”是一个“弱引用(WeakReference)”，在Java中，WeakReference和ReferenceQueue 是联合使用的。在WeakHashMap中亦是如此：如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 接着，WeakHashMap会根据“引用队列”，来删除“WeakHashMap中已被GC回收的‘弱键’对应的键值对”。</p>
<h3 id="WeakReference/ReferenceQueue">WeakReference/ReferenceQueue</h3>
<p>详细请移步<a href="http://www.cnblogs.com/skywang12345/p/3311092.html" target="_blank" rel="external">这里</a></p>
<h2 id="SynchronousQueue">SynchronousQueue</h2>
<ul>
<li>没有数据缓冲（size/peek/remove都是直返回0/null/false）</li>
<li>SynchronousQueue的同步使用无锁算法</li>
<li>竞争机制支持公平和非公平两种</li>
<li>其内部也有用到ReentrantLock，不过是在writeObject方法中实现序列化过程中使用的</li>
<li>重点在TransferQueue内部类</li>
<li>其内部若干个方法都有中断</li>
</ul>
<p>具体请看文章底部推荐的两篇文章及SynchronousQueue源码</p>
<h2 id="DelayQueue/DelayedWorkQueue">DelayQueue/DelayedWorkQueue</h2>
<p>关于DelayQueue请移步<a href="http://www.cnblogs.com/jobs/archive/2007/04/27/730255.html" target="_blank" rel="external">这里</a></p>
<p>这里把DelayedWorkQueue拿出来讲是不太恰当的，因为DelayedWorkQueue是ScheduledThreadPoolExecutor的内部类。作为线程安全集合，其内部的同步方法使用的是ReentrantLock锁。下面是它的继承关系：</p>
<pre><code><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedWorkQueue</span> <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">Runnable</span>&gt;
    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">Runnable</span>&gt; </span>{}
</code></pre><p>DelayedWorkQueue内部使用的是数组进行存储</p>
<pre><code><span class="keyword">private</span> RunnableScheduledFuture[] queue =
        <span class="keyword">new</span> RunnableScheduledFuture[INITIAL_CAPACITY];
</code></pre><p>而DelayQueue是用的PriorityQueue。</p>
<blockquote>
<p>这个 DelayedWorkQueue 和另一个 BlockingQueue 的实现 DelayQueue 很像。都是通过二叉堆算法实现排序，同样是在取操作的时候会 block 住知道 delay 到期。不同的是 DelayedWorkQueue 并没有采用 PriorityQueue，而是自己实现的二叉堆算法，不知道这是为什么（我猜是因为同是 1.5 新类，所以没有重用）。</p>
<p>根据二叉堆的定义，DelayedWorkQueue 中的元素第一个元素永远是 delay 时间最小的那个元素，如果 delay 没有到期，take 的时候便会 block 住。</p>
<p>了解了 DelayedWorkQueue，理解 ScheduledThreadPoolExecutor 就容易了。当执行 schedule 方法是。如果不是重复的任务，那任务从 DelayedWorkQueue 取出之后执行完了就结束了。如果是重复的任务，那在执行结束前会重置执行时间并将自己重新加入到 DelayedWorkQueue 中。</p>
</blockquote>
<h2 id="PriorityQueue/PriorityBlockingQueue">PriorityQueue/PriorityBlockingQueue</h2>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://zhangshixi.iteye.com/blog/673789" target="_blank" rel="external">深入Java集合学习系列：LinkedHashMap的实现原理</a></li>
<li>LinkedHashMap的应用场景：<a href="http://blog.csdn.net/exceptional_derek/article/details/11713255" target="_blank" rel="external">如何用LinkedHashMap实现LRU缓存算法</a></li>
<li><a href="http://www.cnblogs.com/skywang12345/p/3310928.html" target="_blank" rel="external">Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a></li>
<li><a href="http://www.cnblogs.com/chenssy/p/3746600.html" target="_blank" rel="external">Java提高篇（二七）——-TreeMap</a></li>
<li>关于fail-fast的几篇文章<ul>
<li><a href="http://stackoverflow.com/questions/17377407/what-is-fail-safe-fail-fast-iterators-in-java-how-they-are-implemented" target="_blank" rel="external">what is fail-safe &amp; fail-fast Iterators in java &amp; how they are implemented</a></li>
<li><a href="http://javahungry.blogspot.com/2014/04/fail-fast-iterator-vs-fail-safe-iterator-difference-with-example-in-java.html" target="_blank" rel="external">Fail Fast vs Fail Safe Iterator in java : Java Developer Interview Questions</a></li>
</ul>
</li>
<li><a href="http://www.cnblogs.com/skywang12345/p/3311092.html" target="_blank" rel="external">Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例</a></li>
<li><a href="http://ifeve.com/java-synchronousqueue/" target="_blank" rel="external">Java并发包中的同步队列SynchronousQueue实现原理</a></li>
<li><a href="http://shift-alt-ctrl.iteye.com/blog/1840385" target="_blank" rel="external">SynchronousQueue(同步队列)</a></li>
<li><a href="http://www.cnblogs.com/jobs/archive/2007/04/27/730255.html" target="_blank" rel="external">精巧好用的DelayQueue</a></li>
<li><a href="http://my.oschina.net/leejun2005/blog/135085" target="_blank" rel="external">基于堆实现的优先级队列：PriorityQueue 解决 Top K 问题</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[总结了目前为止我在Java中没用过或者用的很少的数据结构，比如LinkedHashMap、WeakHashMap、SynchronousQueue和DelayedWorkQueue]]>
    
    </summary>
    
      <category term="数据结构" scheme="http://blog.xumingyang.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Java" scheme="http://blog.xumingyang.cn/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Caching Tutorial]]></title>
    <link href="http://blog.xumingyang.cn/2015/04/06/wiki/Caching%20Tutorial/"/>
    <id>http://blog.xumingyang.cn/2015/04/06/wiki/Caching Tutorial/</id>
    <published>2015-04-06T14:17:16.000Z</published>
    <updated>2015-04-08T06:14:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>全文转载，原地址：<a href="https://www.mnot.net/cache_docs/#BROWSER" target="_blank" rel="external">https://www.mnot.net/cache_docs/#BROWSER</a></p>
<p>中文翻译地址：<a href="http://www.chedong.com/tech/cache_docs.html" target="_blank" rel="external">http://www.chedong.com/tech/cache_docs.html</a></p>
<h2 id="Caching_Tutorial">Caching Tutorial</h2>
<blockquote>
<p>This is an informational document. Although technical in nature, it attempts to make the concepts involved understandable and applicable in real-world situations. Because of this, some aspects of the material are simplified or omitted, for the sake of clarity. If you are interested in the minutia of the subject, please explore the References and Further Information at the end.</p>
</blockquote>
<h3 id="What’s_a_Web_Cache?_Why_do_people_use_them?">What’s a Web Cache? Why do people use them?</h3>
<p>A Web cache sits between one or more Web servers (also known as origin servers) and a client or many clients, and watches requests come by, saving copies of the responses — like HTML pages, images and files (collectively known as representations) — for itself. Then, if there is another request for the same URL, it can use the response that it has, instead of asking the origin server for it again.</p>
<p>There are two main reasons that Web caches are used:</p>
<ul>
<li>To reduce latency — Because the request is satisfied from the cache (which is closer to the client) instead of the origin server, it takes less time for it to get the representation and display it. This makes the Web seem more responsive.</li>
<li>To reduce network traffic — Because representations are reused, it reduces the amount of bandwidth used by a client. This saves money if the client is paying for traffic, and keeps their bandwidth requirements lower and more manageable.</li>
</ul>
<h3 id="Kinds_of_Web_Caches">Kinds of Web Caches</h3>
<h4 id="Browser_Caches">Browser Caches</h4>
<p>If you examine the preferences dialog of any modern Web browser (like Internet Explorer, Safari or Mozilla), you’ll probably notice a “cache” setting. This lets you set aside a section of your computer’s hard disk to store representations that you’ve seen, just for you. The browser cache works according to fairly simple rules. It will check to make sure that the representations are fresh, usually once a session (that is, the once in the current invocation of the browser).</p>
<p>This cache is especially useful when users hit the “back” button or click a link to see a page they’ve just looked at. Also, if you use the same navigation images throughout your site, they’ll be served from browsers’ caches almost instantaneously.</p>
<h4 id="Proxy_Caches">Proxy Caches</h4>
<p>Web proxy caches work on the same principle, but a much larger scale. Proxies serve hundreds or thousands of users in the same way; large corporations and ISPs often set them up on their firewalls, or as standalone devices (also known as intermediaries).</p>
<p>Because proxy caches aren’t part of the client or the origin server, but instead are out on the network, requests have to be routed to them somehow. One way to do this is to use your browser’s proxy setting to manually tell it what proxy to use; another is using interception. Interception proxies have Web requests redirected to them by the underlying network itself, so that clients don’t need to be configured for them, or even know about them.</p>
<p>Proxy caches are a type of shared cache; rather than just having one person using them, they usually have a large number of users, and because of this they are very good at reducing latency and network traffic. That’s because popular representations are reused a number of times.</p>
<h4 id="Gateway_Caches">Gateway Caches</h4>
<p>Also known as “reverse proxy caches” or “surrogate caches,” gateway caches are also intermediaries, but instead of being deployed by network administrators to save bandwidth, they’re typically deployed by Webmasters themselves, to make their sites more scalable, reliable and better performing.</p>
<p>Requests can be routed to gateway caches by a number of methods, but typically some form of load balancer is used to make one or more of them look like the origin server to clients.</p>
<p>Content delivery networks (CDNs) distribute gateway caches throughout the Internet (or a part of it) and sell caching to interested Web sites. Speedera and Akamai are examples of CDNs.</p>
<p>This tutorial focuses mostly on browser and proxy caches, although some of the information is suitable for those interested in gateway caches as well.</p>
<h3 id="Aren’t_Web_Caches_bad_for_me?_Why_should_I_help_them?">Aren’t Web Caches bad for me? Why should I help them?</h3>
<p>Web caching is one of the most misunderstood technologies on the Internet. Webmasters in particular fear losing control of their site, because a proxy cache can “hide” their users from them, making it difficult to see who’s using the site.</p>
<p>Unfortunately for them, even if Web caches didn’t exist, there are too many variables on the Internet to assure that they’ll be able to get an accurate picture of how users see their site. If this is a big concern for you, this tutorial will teach you how to get the statistics you need without making your site cache-unfriendly.</p>
<p>Another concern is that caches can serve content that is out of date, or stale. However, this tutorial can show you how to configure your server to control how your content is cached.</p>
<blockquote>
<p>CDNs are an interesting development, because unlike many proxy caches, their gateway caches are aligned with the interests of the Web site being cached, so that these problems aren’t seen. However, even when you use a CDN, you still have to consider that there will be proxy and browser caches downstream.</p>
</blockquote>
<p>On the other hand, if you plan your site well, caches can help your Web site load faster, and save load on your server and Internet link. The difference can be dramatic; a site that is difficult to cache may take several seconds to load, while one that takes advantage of caching can seem instantaneous in comparison. Users will appreciate a fast-loading site, and will visit more often.</p>
<p>Think of it this way; many large Internet companies are spending millions of dollars setting up farms of servers around the world to replicate their content, in order to make it as fast to access as possible for their users. Caches do the same for you, and they’re even closer to the end user. Best of all, you don’t have to pay for them.</p>
<p>The fact is that proxy and browser caches will be used whether you like it or not. If you don’t configure your site to be cached correctly, it will be cached using whatever defaults the cache’s administrator decides upon.</p>
<h3 id="How_Web_Caches_Work">How Web Caches Work</h3>
<p>All caches have a set of rules that they use to determine when to serve a representation from the cache, if it’s available. Some of these rules are set in the protocols (HTTP 1.0 and 1.1), and some are set by the administrator of the cache (either the user of the browser cache, or the proxy administrator).</p>
<p>Generally speaking, these are the most common rules that are followed (don’t worry if you don’t understand the details, it will be explained below):</p>
<ol>
<li>If the response’s headers tell the cache not to keep it, it won’t.</li>
<li>If the request is authenticated or secure (i.e., HTTPS), it won’t be cached.</li>
<li><p>A cached representation is considered fresh (that is, able to be sent to a client without checking with the origin server) if:</p>
<ol>
<li>It has an expiry time or other age-controlling header set, and is still within the fresh period, or</li>
<li><p>If the cache has seen the representation recently, and it was modified relatively long ago.</p>
<p>Fresh representations are served directly from the cache, without checking with the origin server.</p>
</li>
</ol>
</li>
<li><p>If a representation is stale, the origin server will be asked to validate it, or tell the cache whether the copy that it has is still good.</p>
</li>
<li>Under certain circumstances — for example, when it’s disconnected from a network — a cache can serve stale responses without checking with the origin server.</li>
</ol>
<p>If no validator (an <code>ETag</code> or <code>Last-Modified</code> header) is present on a response, and it doesn’t have any explicit freshness information, it will usually — but not always — be considered uncacheable.</p>
<p>Together, <em>freshness</em> and <em>validation</em> are the most important ways that a cache works with content. A fresh representation will be available instantly from the cache, while a validated representation will avoid sending the entire representation over again if it hasn’t changed.</p>
<h3 id="How_(and_how_not)_to_Control_Caches">How (and how not) to Control Caches</h3>
<p>There are several tools that Web designers and Webmasters can use to fine-tune how caches will treat their sites. It may require getting your hands a little dirty with your server’s configuration, but the results are worth it. For details on how to use these tools with your server, see the Implementation sections below.</p>
<h4 id="HTML_Meta_Tags_and_HTTP_Headers">HTML Meta Tags and HTTP Headers</h4>
<p>HTML authors can put tags in a document’s <head> section that describe its attributes. These meta tags are often used in the belief that they can mark a document as uncacheable, or expire it at a certain time.</head></p>
<p>Meta tags are easy to use, but aren’t very effective. That’s because they’re only honored by a few browser caches, not proxy caches (which almost never read the HTML in the document). While it may be tempting to put a Pragma: no-cache meta tag into a Web page, it won’t necessarily cause it to be kept fresh.</p>
<blockquote>
<p>If your site is hosted at an ISP or hosting farm and they don’t give you the ability to set arbitrary HTTP headers (like Expires and Cache-Control), complain loudly; these are tools necessary for doing your job.</p>
</blockquote>
<p>On the other hand, true HTTP headers give you a lot of control over how both browser caches and proxies handle your representations. They can’t be seen in the HTML, and are usually automatically generated by the Web server. However, you can control them to some degree, depending on the server you use. In the following sections, you’ll see what HTTP headers are interesting, and how to apply them to your site.</p>
<p>HTTP headers are sent by the server before the HTML, and only seen by the browser and any intermediate caches. Typical HTTP 1.1 response headers might look like this:</p>
<pre><code><span class="status">HTTP/1.1 <span class="number">200</span> OK</span>
<span class="attribute">Date</span>: <span class="string">Fri, 30 Oct 1998 13:19:41 GMT</span>
<span class="attribute">Server</span>: <span class="string">Apache/1.3.3 (Unix)</span>
<span class="attribute">Cache-Control</span>: <span class="string">max-age=3600, must-revalidate</span>
<span class="attribute">Expires</span>: <span class="string">Fri, 30 Oct 1998 14:19:41 GMT</span>
<span class="attribute">Last-Modified</span>: <span class="string">Mon, 29 Jun 1998 02:28:12 GMT</span>
<span class="attribute">ETag</span>: <span class="string">"3e86-410-3596fbbc"</span>
<span class="attribute">Content-Length</span>: <span class="string">1040</span>
<span class="attribute">Content-Type</span>: <span class="string">text/html</span>
</code></pre><p>The HTML would follow these headers, separated by a blank line. See the Implementation sections for information about how to set HTTP headers.</p>
<h4 id="Pragma_HTTP_Headers_(and_why_they_don’t_work)">Pragma HTTP Headers (and why they don’t work)</h4>
<p>Many people believe that assigning a Pragma: no-cache HTTP header to a representation will make it uncacheable. This is not necessarily true; the HTTP specification does not set any guidelines for Pragma response headers; instead, Pragma request headers (the headers that a browser sends to a server) are discussed. Although a few caches may honor this header, the majority won’t, and it won’t have any effect. Use the headers below instead.</p>
<h4 id="Controlling_Freshness_with_the_Expires_HTTP_Header">Controlling Freshness with the Expires HTTP Header</h4>
<p>The <code>Expires</code> HTTP header is a basic means of controlling caches; it tells all caches how long the associated representation is fresh for. After that time, caches will always check back with the origin server to see if a document is changed. Expires headers are supported by practically every cache.</p>
<p>Most Web servers allow you to set Expires response headers in a number of ways. Commonly, they will allow setting an absolute time to expire, a time based on the last time that the client retrieved the representation (last access time), or a time based on the last time the document changed on your server (last modification time).</p>
<p><code>Expires</code> headers are especially good for making static images (like navigation bars and buttons) cacheable. Because they don’t change much, you can set extremely long expiry time on them, making your site appear much more responsive to your users. They’re also useful for controlling caching of a page that is regularly changed. For instance, if you update a news page once a day at 6am, you can set the representation to expire at that time, so caches will know when to get a fresh copy, without users having to hit ‘reload’.</p>
<p>The <strong>only</strong> value valid in an Expires header is a HTTP date; anything else will most likely be interpreted as ‘in the past’, so that the representation is uncacheable. Also, remember that the time in a HTTP date is Greenwich Mean Time (GMT), not local time.</p>
<p>For example:</p>
<pre><code><span class="tag">Expires</span>: <span class="tag">Fri</span>, 30 <span class="tag">Oct</span> 1998 14<span class="pseudo">:19</span><span class="pseudo">:41</span> <span class="tag">GMT</span>
</code></pre><p>Although the Expires header is useful, it has some limitations. First, because there’s a date involved, the clocks on the Web server and the cache must be synchronised; if they have a different idea of the time, the intended results won’t be achieved, and caches might wrongly consider stale content as fresh.</p>
<p>Another problem with Expires is that it’s easy to forget that you’ve set some content to expire at a particular time. If you don’t update an Expires time before it passes, each and every request will go back to your Web server, increasing load and latency.</p>
<blockquote>
<p>It’s important to make sure that your Web server’s clock is accurate if you use the Expires header. One way to do this is using the <a href="http://www.ntp.org/" target="_blank" rel="external">Network Time Protocol</a> (NTP); talk to your local system administrator to find out more.</p>
</blockquote>
<h4 id="Cache-Control_HTTP_Headers">Cache-Control HTTP Headers</h4>
<p>HTTP 1.1 introduced a new class of headers, Cache-Control response headers, to give Web publishers more control over their content, and to address the limitations of Expires.</p>
<p>Useful Cache-Control response headers include:</p>
<ul>
<li><strong>max-age</strong>=[seconds] — specifies the maximum amount of time that a representation will be considered fresh. Similar to Expires, this directive is relative to the time of the request, rather than absolute. [seconds] is the number of seconds from the time of the request you wish the representation to be fresh for.</li>
<li><strong>s-maxage</strong>=[seconds] — similar to max-age, except that it only applies to shared (e.g., proxy) caches.</li>
<li><strong>public</strong> — marks authenticated responses as cacheable; normally, if HTTP authentication is required, responses are automatically private.</li>
<li><strong>private</strong> — allows caches that are specific to one user (e.g., in a browser) to store the response; shared caches (e.g., in a proxy) may not.</li>
<li><strong>no-cache</strong> — forces caches to submit the request to the origin server for validation before releasing a cached copy, every time. This is useful to assure that authentication is respected (in combination with public), or to maintain rigid freshness, without sacrificing all of the benefits of caching.</li>
<li><strong>no-store</strong> — instructs caches not to keep a copy of the representation under any conditions.</li>
<li><strong>must-revalidate</strong> — tells caches that they must obey any freshness information you give them about a representation. HTTP allows caches to serve stale representations under special conditions; by specifying this header, you’re telling the cache that you want it to strictly follow your rules.</li>
<li><strong>proxy-revalidate</strong> — similar to must-revalidate, except that it only applies to proxy caches.</li>
</ul>
<p>For example:</p>
<pre><code>Cache-Contro<span class="variable">l:</span> <span class="built_in">max</span>-age=<span class="number">3600</span>, must-revalidate
</code></pre><p>When both Cache-Control and Expires are present, Cache-Control takes precedence. If you plan to use the Cache-Control headers, you should have a look at the excellent documentation in HTTP 1.1; see References and Further Information.</p>
<h4 id="Validators_and_Validation">Validators and Validation</h4>
<p>In How Web Caches Work, we said that validation is used by servers and caches to communicate when a representation has changed. By using it, caches avoid having to download the entire representation when they already have a copy locally, but they’re not sure if it’s still fresh.</p>
<p>Validators are very important; if one isn’t present, and there isn’t any freshness information (<code>Expires</code> or <code>Cache-Control</code>) available, caches will not store a representation at all.</p>
<p>The most common validator is the time that the document last changed, as communicated in Last-Modified header. When a cache has a representation stored that includes a <code>Last-Modified</code> header, it can use it to ask the server if the representation has changed since the last time it was seen, with an <code>If-Modified-Since</code> request.</p>
<p>HTTP 1.1 introduced a new kind of validator called the ETag. ETags are unique identifiers that are generated by the server and changed every time the representation does. Because the server controls how the ETag is generated, caches can be sure that if the ETag matches when they make a If-None-Match request, the representation really is the same.</p>
<p>Almost all caches use Last-Modified times as validators; ETag validation is also becoming prevalent.</p>
<p>Most modern Web servers will generate both ETag and Last-Modified headers to use as validators for static content (i.e., files) automatically; you won’t have to do anything. However, they don’t know enough about dynamic content (like CGI, ASP or database sites) to generate them; see Writing Cache-Aware Scripts.</p>
<h3 id="Tips_for_Building_a_Cache-Aware_Site">Tips for Building a Cache-Aware Site</h3>
<p>Besides using freshness information and validation, there are a number of other things you can do to make your site more cache-friendly.</p>
<ul>
<li><strong>Use URLs consistently</strong> — this is the golden rule of caching. If you serve the same content on different pages, to different users, or from different sites, it should use the same URL. This is the easiest and most effective way to make your site cache-friendly. For example, if you use “/index.html” in your HTML as a reference once, always use it that way.</li>
<li><strong>Use a common library of images</strong> and other elements and refer back to them from different places.</li>
<li><strong>Make caches store images and pages that don’t change often</strong> by using a Cache-Control: max-age header with a large value.</li>
<li><strong>Make caches recognise regularly updated pages</strong> by specifying an appropriate max-age or expiration time.<br>If a resource (especially a downloadable file) changes, change its name. That way, you can make it expire far in the future, and still guarantee that the correct version is served; the page that links to it is the only one that will need a short expiry time.</li>
<li><strong>Don’t change files unnecessarily</strong>. If you do, everything will have a falsely young Last-Modified date. For instance, when updating your site, don’t copy over the entire site; just move the files that you’ve changed.</li>
<li><strong>Use cookies only where necessary </strong>— cookies are difficult to cache, and aren’t needed in most situations. If you must use a cookie, limit its use to dynamic pages.</li>
<li><strong>Minimize use of SSL </strong>— because encrypted pages are not stored by shared caches, use them only when you have to, and use images on SSL pages sparingly.</li>
<li><strong>Check your pages with REDbot </strong>— it can help you apply many of the concepts in this tutorial.</li>
</ul>
<h3 id="Writing_Cache-Aware_Scripts">Writing Cache-Aware Scripts</h3>
<p>By default, most scripts won’t return a validator (a Last-Modified or ETag response header) or freshness information (Expires or Cache-Control). While some scripts really are dynamic (meaning that they return a different response for every request), many (like search engines and database-driven sites) can benefit from being cache-friendly.</p>
<p>Generally speaking, if a script produces output that is reproducible with the same request at a later time (whether it be minutes or days later), it should be cacheable. If the content of the script changes only depending on what’s in the URL, it is cacheable; if the output depends on a cookie, authentication information or other external criteria, it probably isn’t.</p>
<ul>
<li>The best way to make a script cache-friendly (as well as perform better) is to dump its content to a plain file whenever it changes. The Web server can then treat it like any other Web page, generating and using validators, which makes your life easier. Remember to only write files that have changed, so the Last-Modified times are preserved.</li>
<li>Another way to make a script cacheable in a limited fashion is to set an age-related header for as far in the future as practical. Although this can be done with Expires, it’s probably easiest to do so with Cache-Control: max-age, which will make the request fresh for an amount of time after the request.</li>
<li>If you can’t do that, you’ll need to make the script generate a validator, and then respond to If-Modified-Since and/or If-None-Match requests. This can be done by parsing the HTTP headers, and then responding with 304 Not Modified when appropriate. Unfortunately, this is not a trival task.</li>
</ul>
<p>Some other tips;</p>
<ul>
<li><strong>Don’t use POST</strong> unless it’s appropriate. Responses to the POST method aren’t kept by most caches; if you send information in the path or query (via GET), caches can store that information for the future.</li>
<li><strong>Don’t embed user-specific information in the URL</strong> unless the content generated is completely unique to that user.</li>
<li><strong>Don’t count on all requests from a user coming from the same host</strong>, because caches often work together.</li>
<li><strong>Generate Content-Length response headers. </strong>It’s easy to do, and it will allow the response of your script to be used in a persistent connection. This allows clients to request multiple representations on one TCP/IP connection, instead of setting up a connection for every request. It makes your site seem much faster.<br>See the Implementation Notes for more specific information.</li>
</ul>
<h3 id="Frequently_Asked_Questions">Frequently Asked Questions</h3>
<h4 id="What_are_the_most_important_things_to_make_cacheable?">What are the most important things to make cacheable?</h4>
<p>A good strategy is to identify the most popular, largest representations (especially images) and work with them first.</p>
<h4 id="How_can_I_make_my_pages_as_fast_as_possible_with_caches?">How can I make my pages as fast as possible with caches?</h4>
<p>The most cacheable representation is one with a long freshness time set. Validation does help reduce the time that it takes to see a representation, but the cache still has to contact the origin server to see if it’s fresh. If the cache already knows it’s fresh, it will be served directly.</p>
<h4 id="I_understand_that_caching_is_good,_but_I_need_to_keep_statistics_on_how_many_people_visit_my_page!">I understand that caching is good, but I need to keep statistics on how many people visit my page!</h4>
<p>If you must know every time a page is accessed, select ONE small item on a page (or the page itself), and make it uncacheable, by giving it a suitable headers. For example, you could refer to a 1x1 transparent uncacheable image from each page. The Referer header will contain information about what page called it.</p>
<p>Be aware that even this will not give truly accurate statistics about your users, and is unfriendly to the Internet and your users; it generates unnecessary traffic, and forces people to wait for that uncached item to be downloaded. For more information about this, see On Interpreting Access Statistics in the references.</p>
<h4 id="How_can_I_see_a_representation’s_HTTP_headers?">How can I see a representation’s HTTP headers?</h4>
<p>Many Web browsers let you see the Expires and Last-Modified headers are in a “page info” or similar interface. If available, this will give you a menu of the page and any representations (like images) associated with it, along with their details.</p>
<p>To see the full headers of a representation, you can manually connect to the Web server using a Telnet client.</p>
<p>To do so, you may need to type the port (be default, 80) into a separate field, or you may need to connect to www.example.com:80 or www.example.com 80 (note the space). Consult your Telnet client’s documentation.</p>
<p>Once you’ve opened a connection to the site, type a request for the representation. For instance, if you want to see the headers for <a href="http://www.example.com/foo.html" target="_blank" rel="external">http://www.example.com/foo.html</a>, connect to www.example.com, port 80, and type:</p>
<pre><code>GET /foo.html HTTP/1.1 [return]
Host: www.example.com [<span class="link_label">return</span>][<span class="link_reference">return</span>]
</code></pre><p>Press the Return key every time you see [return]; make sure to press it twice at the end. This will print the headers, and then the full representation. To see the headers only, substitute HEAD for GET.</p>
<h4 id="My_pages_are_password-protected;_how_do_proxy_caches_deal_with_them?">My pages are password-protected; how do proxy caches deal with them?</h4>
<p>By default, pages protected with HTTP authentication are considered private; they will not be kept by shared caches. However, you can make authenticated pages public with a Cache-Control: public header; HTTP 1.1-compliant caches will then allow them to be cached.</p>
<p>If you’d like such pages to be cacheable, but still authenticated for every user, combine the Cache-Control: public and no-cache headers. This tells the cache that it must submit the new client’s authentication information to the origin server before releasing the representation from the cache. This would look like:</p>
<pre><code><span class="operator"><span class="keyword">Cache</span>-Control: <span class="keyword">public</span>, <span class="keyword">no</span>-<span class="keyword">cache</span></span>
</code></pre><p>Whether or not this is done, it’s best to minimize use of authentication; for example, if your images are not sensitive, put them in a separate directory and configure your server not to force authentication for it. That way, those images will be naturally cacheable.</p>
<h4 id="Should_I_worry_about_security_if_people_access_my_site_through_a_cache?">Should I worry about security if people access my site through a cache?</h4>
<p>SSL pages are not cached (or decrypted) by proxy caches, so you don’t have to worry about that. However, because caches store non-SSL requests and URLs fetched through them, you should be conscious about unsecured sites; an unscrupulous administrator could conceivably gather information about their users, especially in the URL.</p>
<p>In fact, any administrator on the network between your server and your clients could gather this type of information. One particular problem is when CGI scripts put usernames and passwords in the URL itself; this makes it trivial for others to find and use their login.</p>
<p>If you’re aware of the issues surrounding Web security in general, you shouldn’t have any surprises from proxy caches.</p>
<h4 id="I’m_looking_for_an_integrated_Web_publishing_solution-_Which_ones_are_cache-aware?">I’m looking for an integrated Web publishing solution. Which ones are cache-aware?</h4>
<p>It varies. Generally speaking, the more complex a solution is, the more difficult it is to cache. The worst are ones which dynamically generate all content and don’t provide validators; they may not be cacheable at all. Speak with your vendor’s technical staff for more information, and see the Implementation notes below.</p>
<h4 id="My_images_expire_a_month_from_now,_but_I_need_to_change_them_in_the_caches_now!">My images expire a month from now, but I need to change them in the caches now!</h4>
<p>The Expires header can’t be circumvented; unless the cache (either browser or proxy) runs out of room and has to delete the representations, the cached copy will be used until then.</p>
<p>The most effective solution is to change any links to them; that way, completely new representations will be loaded fresh from the origin server. Remember that any page that refers to these representations will be cached as well. Because of this, it’s best to make static images and similar representations very cacheable, while keeping the HTML pages that refer to them on a tight leash.</p>
<p>If you want to reload a representation from a specific cache, you can either force a reload (in Firefox, holding down shift while pressing ‘reload’ will do this by issuing a Pragma: no-cache request header) while using the cache. Or, you can have the cache administrator delete the representation through their interface.</p>
<h4 id="I_run_a_Web_Hosting_service-_How_can_I_let_my_users_publish_cache-friendly_pages?">I run a Web Hosting service. How can I let my users publish cache-friendly pages?</h4>
<p>If you’re using Apache, consider allowing them to use .htaccess files and providing appropriate documentation.</p>
<p>Otherwise, you can establish predetermined areas for various caching attributes in each virtual server. For instance, you could specify a directory /cache-1m that will be cached for one month after access, and a /no-cache area that will be served with headers instructing caches not to store representations from it.</p>
<p>Whatever you are able to do, it is best to work with your largest customers first on caching. Most of the savings (in bandwidth and in load on your servers) will be realized from high-volume sites.</p>
<h4 id="I’ve_marked_my_pages_as_cacheable,_but_my_browser_keeps_requesting_them_on_every_request-_How_do_I_force_the_cache_to_keep_representations_of_them?">I’ve marked my pages as cacheable, but my browser keeps requesting them on every request. How do I force the cache to keep representations of them?</h4>
<p>Caches aren’t required to keep a representation and reuse it; they’re only required to not keep or use them under some conditions. All caches make decisions about which representations to keep based upon their size, type (e.g., image vs. html), or by how much space they have left to keep local copies. Yours may not be considered worth keeping around, compared to more popular or larger representations.</p>
<p>Some caches do allow their administrators to prioritize what kinds of representations are kept, and some allow representations to be “pinned” in cache, so that they’re always available.</p>
<h3 id="Implementation_Notes_—_Web_Servers">Implementation Notes — Web Servers</h3>
<p>Generally speaking, it’s best to use the latest version of whatever Web server you’ve chosen to deploy. Not only will they likely contain more cache-friendly features, new versions also usually have important security and performance improvements.</p>
<h4 id="Apache_HTTP_Server">Apache HTTP Server</h4>
<p>Apache uses optional modules to include headers, including both Expires and Cache-Control. Both modules are available in the 1.2 or greater distribution.</p>
<p>The modules need to be built into Apache; although they are included in the distribution, they are not turned on by default. To find out if the modules are enabled in your server, find the httpd binary and run httpd -l; this should print a list of the available modules (note that this only lists compiled-in modules; on later versions of Apache, use httpd -M to include dynamically loaded modules as well). The modules we’re looking for are expires_module and headers_module.</p>
<ul>
<li>If they aren’t available, and you have administrative access, you can recompile Apache to include them. This can be done either by uncommenting the appropriate lines in the Configuration file, or using the -enable-module=expires and -enable-module=headers arguments to configure (1.3 or greater). Consult the INSTALL file found with the Apache distribution.</li>
</ul>
<p>Once you have an Apache with the appropriate modules, you can use mod_expires to specify when representations should expire, either in .htaccess files or in the server’s access.conf file. You can specify expiry from either access or modification time, and apply it to a file type or as a default. See the module documentation for more information, and speak with your local Apache guru if you have trouble.</p>
<p>To apply Cache-Control headers, you’ll need to use the mod_headers module, which allows you to specify arbitrary HTTP headers for a resource. See the mod_headers documentation.</p>
<p>Here’s an example .htaccess file that demonstrates the use of some headers.</p>
<ul>
<li><p>htaccess files allow web publishers to use commands normally only found in configuration files. They affect the content of the directory they’re in and their subdirectories. Talk to your server administrator to find out if they’re enabled.</p>
<h3 id="activate_mod_expires">activate mod_expires</h3>
<p>  ExpiresActive On</p>
<h3 id="Expire_-gif’s_1_month_from_when_they’re_accessed">Expire .gif’s 1 month from when they’re accessed</h3>
<p>  ExpiresByType image/gif A2592000</p>
<h3 id="Expire_everything_else_1_day_from_when_it’s_last_modified">Expire everything else 1 day from when it’s last modified</h3>
<h3 id="(this_uses_the_Alternative_syntax)">(this uses the Alternative syntax)</h3>
<p>  ExpiresDefault “modification plus 1 day”</p>
<h3 id="Apply_a_Cache-Control_header_to_index-html">Apply a Cache-Control header to index.html</h3>
  <files index.html=""><br>  Header append Cache-Control “public, must-revalidate”<br>  </files>
</li>
<li><p>Note that mod_expires automatically calculates and inserts a Cache-Control:max-age header as appropriate.<br>Apache 2’s configuration is very similar to that of 1.3; see the 2.2 mod_expires and mod_headers documentation for more information.</p>
</li>
</ul>
<h4 id="Microsoft_IIS">Microsoft IIS</h4>
<p>Microsoft’s Internet Information Server makes it very easy to set headers in a somewhat flexible way. Note that this is only possible in version 4 of the server, which will run only on NT Server.</p>
<p>To specify headers for an area of a site, select it in the Administration Tools interface, and bring up its properties. After selecting the HTTP Headers tab, you should see two interesting areas; Enable Content Expiration and Custom HTTP headers. The first should be self-explanatory, and the second can be used to apply Cache-Control headers.</p>
<p>See the ASP section below for information about setting headers in Active Server Pages. It is also possible to set headers from ISAPI modules; refer to MSDN for details.</p>
<h4 id="Netscape/iPlanet_Enterprise_Server">Netscape/iPlanet Enterprise Server</h4>
<p>As of version 3.6, Enterprise Server does not provide any obvious way to set Expires headers. However, it has supported HTTP 1.1 features since version 3.0. This means that HTTP 1.1 caches (proxy and browser) will be able to take advantage of Cache-Control settings you make.</p>
<p>To use Cache-Control headers, choose Content Management | Cache Control Directives in the administration server. Then, using the Resource Picker, choose the directory where you want to set the headers. After setting the headers, click ‘OK’. For more information, see the NES manual.</p>
<h3 id="Implementation_Notes_—_Server-Side_Scripting">Implementation Notes — Server-Side Scripting</h3>
<p>Because the emphasis in server-side scripting is on dynamic content, it doesn’t make for very cacheable pages, even when the content could be cached. If your content changes often, but not on every page hit, consider setting a Cache-Control: max-age header; most users access pages again in a relatively short period of time. For instance, when users hit the ‘back’ button, if there isn’t any validator or freshness information available, they’ll have to wait until the page is re-downloaded from the server to see it.</p>
<blockquote>
<p>One thing to keep in mind is that it may be easier to set HTTP headers with your Web server rather than in the scripting language. Try both.</p>
</blockquote>
<h4 id="CGI">CGI</h4>
<p>CGI scripts are one of the most popular ways to generate content. You can easily append HTTP response headers by adding them before you send the body; Most CGI implementations already require you to do this for the Content-Type header. For instance, in Perl;</p>
<pre><code><span class="comment">#!/usr/bin/perl</span>
<span class="literal">print</span> <span class="string">"Content-type: text/html\n"</span><span class="comment">;</span>
<span class="literal">print</span> <span class="string">"Expires: Thu, 29 Oct 1998 17:04:19 GMT\n"</span><span class="comment">;</span>
<span class="literal">print</span> <span class="string">"\n"</span><span class="comment">;</span>
<span class="comment">### the content body follows...</span>
</code></pre><p>Since it’s all text, you can easily generate Expires and other date-related headers with in-built functions. It’s even easier if you use Cache-Control: max-age;</p>
<pre><code><span class="literal">print</span> <span class="string">"Cache-Control: max-age=600\n"</span><span class="comment">;</span>
</code></pre><p>This will make the script cacheable for 10 minutes after the request, so that if the user hits the ‘back’ button, they won’t be resubmitting the request.</p>
<p>The CGI specification also makes request headers that the client sends available in the environment of the script; each header has ‘HTTP_’ prepended to its name. So, if a client makes an If-Modified-Since request, it will show up as HTTP_IF_MODIFIED_SINCE.</p>
<p>See also the cgi_buffer library, which automatically handles ETag generation and validation, Content-Length generation and gzip content-coding for Perl and Python CGI scripts with a one-line include. The Python version can also be used to wrap arbitrary CGI scripts with.</p>
<h4 id="Server_Side_Includes">Server Side Includes</h4>
<p>SSI (often used with the extension .shtml) is one of the first ways that Web publishers were able to get dynamic content into pages. By using special tags in the pages, a limited form of in-HTML scripting was available.</p>
<p>Most implementations of SSI do not set validators, and as such are not cacheable. However, Apache’s implementation does allow users to specify which SSI files can be cached, by setting the group execute permissions on the appropriate files, combined with the XbitHack full directive. For more information, see the mod_include documentation.</p>
<h4 id="PHP">PHP</h4>
<p>PHP is a server-side scripting language that, when built into the server, can be used to embed scripts inside a page’s HTML, much like SSI, but with a far larger number of options. PHP can be used as a CGI script on any Web server (Unix or Windows), or as an Apache module.</p>
<p>By default, representations processed by PHP are not assigned validators, and are therefore uncacheable. However, developers can set HTTP headers by using the Header() function.</p>
<p>For example, this will create a Cache-Control header, as well as an Expires header three days in the future:</p>
<pre><code><span class="php"><span class="preprocessor">&lt;?php</span>
 Header(<span class="string">"Cache-Control: must-revalidate"</span>);

 <span class="variable">$offset</span> = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">3</span>;
 <span class="variable">$ExpStr</span> = <span class="string">"Expires: "</span> . gmdate(<span class="string">"D, d M Y H:i:s"</span>, time() + <span class="variable">$offset</span>) . <span class="string">" GMT"</span>;
 Header(<span class="variable">$ExpStr</span>);
<span class="preprocessor">?&gt;</span></span>
</code></pre><p>Remember that the Header() function MUST come before any other output.</p>
<p>As you can see, you’ll have to create the HTTP date for an Expires header by hand; PHP doesn’t provide a function to do it for you (although recent versions have made it easier; see the <a href="http://php.net/manual/zh/function.date.php" target="_blank" rel="external">PHP’s date documentation</a>). Of course, it’s easy to set a Cache-Control: max-age header, which is just as good for most situations.</p>
<p>For more information, see the<a href="http://php.net/manual/zh/function.header.php" target="_blank" rel="external"> manual entry for header.</a></p>
<p>See also the cgi_buffer library, which automatically handles ETag generation and validation, Content-Length generation and gzip content-coding for PHP scripts with a one-line include.</p>
<h4 id="Cold_Fusion">Cold Fusion</h4>
<p>Cold Fusion, by Macromedia is a commercial server-side scripting engine, with support for several Web servers on Windows, Linux and several flavors of Unix.</p>
<p>Cold Fusion makes setting arbitrary HTTP headers relatively easy, with the CFHEADER tag. Unfortunately, their example for setting an Expires header, as below, is a bit misleading.</p>
<pre><code>&lt;CFHEADER <span class="variable">NAME=</span><span class="string">"Expires"</span> <span class="variable">VALUE=</span><span class="string">"#Now()#"</span>&gt;
</code></pre><p>It doesn’t work like you might think, because the time (in this case, when the request is made) doesn’t get converted to a HTTP-valid date; instead, it just gets printed as a representation of Cold Fusion’s Date/Time object. Most clients will either ignore such a value, or convert it to a default, like January 1, 1970.</p>
<p>However, Cold Fusion does provide a date formatting function that will do the job; GetHttpTimeString. In combination with DateAdd, it’s easy to set Expires dates; here, we set a header to declare that representations of the page expire in one month;</p>
<pre><code>&lt;cfheader <span class="variable">name=</span><span class="string">"Expires"</span> 
  <span class="variable">value=</span><span class="string">"#GetHttpTimeString(DateAdd('m', 1, Now()))#"</span>&gt;
</code></pre><p>You can also use the CFHEADER tag to set Cache-Control: max-age and other headers.</p>
<p>Remember that Web server headers are passed through in some deployments of Cold Fusion (such as CGI); check yours to determine whether you can use this to your advantage, by setting headers on the server instead of in Cold Fusion.</p>
<h4 id="ASP_and_ASP-NET">ASP and ASP.NET</h4>
<p>When setting HTTP headers from ASPs, make sure you either place the Response method calls before any HTML generation, or use Response.Buffer to buffer the output. Also, note that some versions of IIS set a Cache-Control: private header on ASPs by default, and must be declared public to be cacheable by shared caches.</p>
<blockquote>
<p>Active Server Pages, built into IIS and also available for other Web servers, also allows you to set HTTP headers. For instance, to set an expiry time, you can use the properties of the Response object;</p>
</blockquote>
<pre><code><span class="vbscript">&lt;% <span class="built_in">Response</span>.Expires=<span class="number">1440</span> %&gt;</span>
</code></pre><p>specifying the number of minutes from the request to expire the representation. Cache-Control headers can be added like this:</p>
<pre><code><span class="vbscript">&lt;% <span class="built_in">Response</span>.CacheControl=<span class="string">"public"</span> %&gt;</span>
</code></pre><p>In ASP.NET, Response.Expires is deprecated; the proper way to set cache-related headers is with Response.Cache;</p>
<pre><code><span class="built_in">Response</span>.Cache.SetExpires ( DateTime.<span class="built_in">Now</span>.AddMinutes ( <span class="number">60</span> ) ) ;
<span class="built_in">Response</span>.Cache.SetCacheability ( HttpCacheability.<span class="keyword">Public</span> ) ;
</code></pre><h3 id="References_and_Further_Information">References and Further Information</h3>
<h4 id="HTTP_1-1_Specification">HTTP 1.1 Specification</h4>
<p>The HTTP 1.1 spec has many extensions for making pages cacheable, and is the authoritative guide to implementing the protocol. See sections 13, 14.9, 14.21, and 14.25.</p>
<h4 id="Web-Caching-com">Web-Caching.com</h4>
<p>An excellent introduction to caching concepts, with links to other online resources.</p>
<h4 id="On_Interpreting_Access_Statistics">On Interpreting Access Statistics</h4>
<p>Jeff Goldberg’s informative rant on why you shouldn’t rely on access statistics and hit counters.</p>
<h4 id="REDbot">REDbot</h4>
<p>Examines HTTP resources to determine how they will interact with Web caches, and generally how well they use the protocol.</p>
<h4 id="cgi_buffer_Library">cgi_buffer Library</h4>
<p>One-line include in Perl CGI, Python CGI and PHP scripts automatically handles ETag generation and validation, Content-Length generation and gzip Content-Encoding — correctly. The Python version can also be used as a wrapper around arbitrary CGI scripts.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2>
<p>全文转载，原地址：<a href="https://www.mnot.net/cache_docs/#BROWSER" target="_blank" rel="external">https://www.mnot.net/cache]]>
    </summary>
    
      <category term="干货" scheme="http://blog.xumingyang.cn/categories/%E5%B9%B2%E8%B4%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计合适的数据结构(二)]]></title>
    <link href="http://blog.xumingyang.cn/2015/04/03/%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97(%E4%BA%8C)/"/>
    <id>http://blog.xumingyang.cn/2015/04/03/设计数据结构系列(二)/</id>
    <published>2015-04-03T19:28:31.000Z</published>
    <updated>2015-04-03T09:10:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题背景">问题背景</h2>
<blockquote>
<p>设计实现一个抽象数据类型，能支持下列操作：</p>
<ul>
<li>insert(x)：如果x不在数据结构中，则插入x</li>
<li>delete(x)：从数据结构中删除x（如果x存在）</li>
<li>find_next(x)：在数据结构中搜索比x大的最小关键字</li>
</ul>
<p>所有这些操作在最坏情况下的复杂度要求为O(log n)，其中n是数据结构中元素的个数。</p>
</blockquote>
<p>分析：上面的insert和delete这两个操作都需要先在数据结构中查找x。查找如果要控制在O(log n)的时间复杂度的话一般就是二叉搜索树和二分查找，但是二分查找需要基于有序线性表，所以不一定可以。</p>
<h3 id="树">树</h3>
<p>对于二叉搜索树需要注意其退化成链表的情况（这样就不能保证O(log n)的时间复杂度了），此时需要加上平衡算法。如何保持二叉树的节点分布均匀的平衡算法是平衡二叉树的关键；平衡算法是一种在B树中插入和删除节点的策略。关于二叉搜索树及相关的平衡树（AVL树，红黑树等）可以参考<a href="http://blog.csdn.net/chlele0105/article/details/8473846" target="_blank" rel="external">这篇博文</a>。</p>
<h3 id="跳表">跳表</h3>
<p>如果不使用树，其实还可以使用跳表，同样可以把插入删除的时间复杂度控制在O(log n)，至于查找比x大的最小关键字也不难在O(log n)时间内找到。关于跳表，这里就不展开描述了（其实让我描述也说不清楚 = = ），同样，推荐文章给大家看：<a href="http://kenby.iteye.com/blog/1187303" target="_blank" rel="external">这篇</a>和<a href="http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html" target="_blank" rel="external">这篇</a>。</p>
<h3 id="放弃数组或者链表">放弃数组或者链表</h3>
<p>如果想使用二分查找，那么首先数据结构必须是有序的线性表。如此一来，那么插入和删除的时候要做到O(log n)就比较困难了，因为如果选择数组作为底层存储的话，虽然查找可以做到O(log n)，但是插入和删除的时间复杂度是O(n)。如果选择链表，那二分查找本身就做不到O(log n)的时间复杂度了，即使插入和删除是O(1)也无济于事。</p>
<h3 id="其他方案">其他方案</h3>
<p>还有没有其他的方法呢，不会只有BST一类的和跳表这两种吧。。。</p>
<h2 id="扩展问题一">扩展问题一</h2>
<blockquote>
<p>insert和delete函数要求不变，第三个方法改成实现find_smallest(k)：在数据结构中搜索第k小的关键字。所有这些操作在最坏情况下的复杂度要求为O(log n)。</p>
</blockquote>
<p>PS：可以使用AVL树，在每个节点上增加一个数据域：存放这个节点的子节点的个数（包括自己）。</p>
<h2 id="扩展问题二">扩展问题二</h2>
<blockquote>
<p>insert和delete函数要求不变，第三个方法改成实现find_next(x,k)：在数据结构中把比x大的关键字从小到大排序，搜索第k个这样的关键字。所有这些操作在最坏情况下的复杂度要求为O(log n)。</p>
</blockquote>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://blog.csdn.net/chlele0105/article/details/8473846" target="_blank" rel="external">B树、B+树、AVL树、红黑树</a></li>
<li><a href="http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html" target="_blank" rel="external">跳表SkipList</a></li>
<li><a href="http://kenby.iteye.com/blog/1187303" target="_blank" rel="external">SkipList跳表</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="问题背景">问题背景</h2>
<blockquote>
<p>设计实现一个抽象数据类型，能支持下列操作：</p>
<ul>
<li>insert(x)：如果x不在数据结构中，则插入x</li>
<li>delete(x)：从数据结构中删除x（如果x存在）</li]]>
    </summary>
    
      <category term="数据结构" scheme="http://blog.xumingyang.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="基础知识" scheme="http://blog.xumingyang.cn/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计合适的数据结构(一)]]></title>
    <link href="http://blog.xumingyang.cn/2015/04/02/%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97(%E4%B8%80)/"/>
    <id>http://blog.xumingyang.cn/2015/04/02/设计数据结构系列(一)/</id>
    <published>2015-04-02T12:28:31.000Z</published>
    <updated>2015-04-03T09:11:16.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题背景">问题背景</h2>
<blockquote>
<p>设计实现一个抽象数据类型，能支持下列操作：</p>
<p>Insert(x):即使x已在数据结构中，也要进行插入操作，换句话说，数据结构支持重复的元素。</p>
<p>Remove():从数据结构中删除任意一个元素，然后返回该值。同样，任意元素都可以被删除。如果同一个元素有多份副本，那么只需要删除其中一份副本。</p>
<p>这种抽象数据类型又称为池（或者包）。它对存储工作很有用，产生的新工作被插入到池中；而当有工人可用时，将从池中删除一项工作。所有的操作都只需要O(1)的时间。</p>
</blockquote>
<h3 id="第一版">第一版</h3>
<p>本题初见，感觉队列(或者栈)比较满足，因为只需要支持插入操作和删除任意一个元素并返回该值就行，甚至对于重复元素也不需要进行特别的修改，代码如下：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pool</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6070787603102142467</span>L;
    Queue&lt;E&gt; queue = <span class="keyword">new</span> LinkedList&lt;E&gt;();

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span>(E e){
        queue.add(e);
    }

    <span class="keyword">public</span> E <span class="title">remove</span>(){
        <span class="keyword">return</span> queue.poll();
    }

}
</code></pre><p>这种情况对于工人消耗工作的速度<code>大于等于</code>工作生成的速度时，比较推荐。因为队列不会增长的很快，否则，数据结构中存储的元素数量会越来越多，最终甚至会导致OOM(OutOfMemery)。一般可以给队列设置个容量最大值，当触发这个最大值时，则不会再进行插入操作。多线程情况下，就是生产线程进入wait状态(当队列中有元素删除时，再将生产队列唤醒)。</p>
<h3 id="第二版">第二版</h3>
<p>这里有个问题，对于重复工作——也就是数据结构中有很多副本的话，这个数据结构其实是有压缩的空间的，增加一个计数部分。比如像下面这样增加一个内部类：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> Entry&lt;E&gt;{
    <span class="keyword">int</span> count = <span class="number">0</span>;
    E e;
    Entry(E e){
        <span class="keyword">this</span>.e = e;
    }
    <span class="keyword">private</span> boolean <span class="title">delete</span>(){
        <span class="keyword">if</span>(count &gt; <span class="number">0</span>)
            count--;
        <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }
    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span>(){
        count++;
    }
}
</code></pre><p>但是这样的话每次插入和删除都要遍历一遍，才能确定是否里面存在该值，然后进行对应的count++或者count—操作。虽然省了空间，但是时间复杂度却变成了O(n)。有没有办法能够压缩空间，又让时间复杂度为O(1)呢？</p>
<h3 id="第三版">第三版</h3>
<p>从实际情况来看，回到刚才的情景中，其实“工作”类型数量有限，我们完全可以确定好某个“工作”所在的位置：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Pool&lt;E&gt;{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> Entry&lt;E&gt;{
        <span class="keyword">int</span> count = <span class="number">0</span>;
        E e;
        Entry(E e){
            <span class="keyword">this</span>.e = e;
        }
        <span class="keyword">private</span> boolean <span class="title">delete</span>(){
            <span class="keyword">if</span>(count &gt; <span class="number">0</span>)
                count--;
            <span class="keyword">else</span>
                <span class="keyword">return</span> <span class="keyword">false</span>;
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span>(){
            count++;
        }
    }
    <span class="comment">//默认的工作类型</span>
    <span class="keyword">enum</span> WorkType{
        ONE,TWO,THREE,FOUR;
    }

    Entry[] queue = <span class="keyword">new</span> Entry[WorkType.values().length];
    <span class="keyword">int</span> size = <span class="number">0</span>;

    <span class="comment">/*插入时，先判断e的工作类型，然后再将该工作类型处的Entry的count加一，同时size也加1。E中也需要有描述工作类型的属性。*/</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span>(Entry e){
    }
    <span class="comment">//这个相对复杂些，可操作性也更大    </span>
    <span class="keyword">public</span> Entry <span class="title">remove</span>(){
    }
}
</code></pre><p>可以把数组的每个元素看成一个桶，具体的remove操作，先判断<code>size&gt;0</code>，然后从数组第一个“桶”开始往后看，若该项的<code>count!=0</code>就直接返回对应的Entry，并且count—；基于此，这种方案适用的场景是：</p>
<ul>
<li>工作类型比较少且已知</li>
<li>需要实现工作优先级</li>
</ul>
<p>工作优先级的实现在remove里面，数组中的每个“桶”，删除的时候从优先级高的开始删。</p>
<h3 id="第四版">第四版</h3>
<p>这里可以借鉴Hash。存储工作队列的依然用的数组，具体的存放通过hash来映射。这个版本同上面那个的区别在于：</p>
<ul>
<li>不受限与具体的工作类型</li>
<li>会有空间浪费，但是依然可以保证insert和remove的O(1)时间复杂度</li>
<li>若出现碰撞，则直接进行扩容操作（或者限制每个hash值中链表的长度，参照HashMap）</li>
<li>不利于实现工作优先级</li>
<li>适用于有大量重复工作类型且工作类型未知的情况</li>
</ul>
<p>这里结合了数组和链表的优点。其实HashMap也是如此，一方面吸取了数组的随机存取的优点，另一方面用链表补充了数组某位置碰撞产生的问题。</p>
<h2 id="扩展问题一">扩展问题一</h2>
<blockquote>
<p>假设每个元素在数据结构中只出现一次，那么插入操作就必须检查是否有重复的元素存在。像上题那样实现这种数据类型，而且要加上重复元素检验的功能。在最坏情况下每个操作的复杂度是多少？对平均而言，怎样设计数据结构最好？</p>
</blockquote>
<p>针对上面的第一版，重复元素检验的时间复杂度是O(n)。可以基于第四版进行改进，其实就是使用类似于HashSet的数据结构，天然无重复元素。这样重复元素的检验可以控制在常数时间内，最坏情况也是如此。</p>
<h2 id="扩展问题二">扩展问题二</h2>
<blockquote>
<p>假设所有的元素都可以用1到n直接的整数来编号，且n足够小以至于我们可以分配大小为O(n)的内存。每个元素最多只能出现一次。设计一个算法，其insert和remove操作的时间复杂度为O(1)。</p>
</blockquote>
<p>这种情况其实就是上面第三版考虑的情况，可以直接使用第三版。</p>
<p>第三版中的remove函数其实还是有点问题的，使用数组存储，必须挨个看那个“桶”里面有元素（就是count&gt;0）。其实还是有办法避免这种情况的，就是再搞一个Set，里面存放count&gt;0的“桶”的位置，每次从Set里面取“桶”的编号。不过多了一个维护Set的开销，但是这个的时间复杂度是O(1)的，所以还是可以满足题目要求的。</p>
<p>其实因为n比较小，在实际情况中挨个看也不会消耗很多时间的。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>本题来自<a href="http://book.douban.com/subject/1436134/" target="_blank" rel="external">《算法引论》</a>P63页习题4.10-4.12</li>
<li>关于HashMap的一些资料<ul>
<li>首推HashMap的源码</li>
<li><a href="http://beyond99.blog.51cto.com/1469451/429789" target="_blank" rel="external">Java HashMap实现详解</a></li>
<li><a href="http://github.thinkingbar.com/hashmap-analysis/" target="_blank" rel="external">HashMap源码剖析</a></li>
<li><a href="http://stackoverflow.com/questions/9335169/understanding-strange-java-hash-function" target="_blank" rel="external">Understanding strange Java hash function</a></li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="问题背景">问题背景</h2>
<blockquote>
<p>设计实现一个抽象数据类型，能支持下列操作：</p>
<p>Insert(x):即使x已在数据结构中，也要进行插入操作，换句话说，数据结构支持重复的元素。</p>
<p>Remove():从数据结构中删]]>
    </summary>
    
      <category term="数据结构" scheme="http://blog.xumingyang.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="基础知识" scheme="http://blog.xumingyang.cn/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[源码浅析-Callable和Future]]></title>
    <link href="http://blog.xumingyang.cn/2015/03/28/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Callable/"/>
    <id>http://blog.xumingyang.cn/2015/03/28/源码分析-Callable/</id>
    <published>2015-03-28T14:28:31.000Z</published>
    <updated>2015-03-28T13:43:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="用Callable接口可以干啥">用Callable接口可以干啥</h2>
<p>简单来说，以前多线程的run方法返回值是void，那现在我想让各个线程有返回值咋办：使用Callable接口！</p>
<p>话不多说，先上例子，这个例子引自“飘过的小牛”的<a href="http://github.thinkingbar.com/thinking_in_java_chapter21-part01/" target="_blank" rel="external">这篇文章中</a>。代码如下：</p>
<pre><code>class <span class="type">TaskWithResult</span> implements <span class="type">Callable</span>&lt;<span class="type">String</span>&gt; {
    private <span class="type">int</span> id;
    public <span class="type">TaskWithResult</span>(<span class="type">int</span> id) {
        this.id = id;
    }
    //必须重写call函数
    @<span class="type">Override</span>
    public <span class="type">String</span> call() {
          <span class="keyword">return</span> <span class="string">"result of TaskWithResult: "</span> + id;
    }
}
public class <span class="type">Test</span> {
    public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) {
        <span class="type">ExecutorService</span> exec = <span class="type">Executors</span>.newCachedThreadPool();
        <span class="type">ArrayList</span>&lt;<span class="type">Future</span>&lt;<span class="type">String</span>&gt;&gt; <span class="literal">result</span> = new <span class="type">ArrayList</span>&lt;<span class="type">Future</span>&lt;<span class="type">String</span>&gt;&gt;();
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
            <span class="literal">result</span>.add(exec.submit(new <span class="type">TaskWithResult</span>(i)));
        }

        <span class="keyword">for</span>(<span class="type">Future</span>&lt;<span class="type">String</span>&gt; fs : <span class="literal">result</span>) {
            <span class="keyword">try</span> {
                <span class="type">System</span>.<span class="keyword">out</span>.println(fs.get());
            } catch (<span class="type">InterruptedException</span> | <span class="type">ExecutionException</span> e) {
                // <span class="type">TODO</span> <span class="type">Auto</span>-generated catch <span class="keyword">block</span>
                e.printStackTrace();
            } <span class="keyword">finally</span> {
                exec.shutdown();
            }
        }
    }
}
</code></pre><p><a id="more"></a><br>这个例子的完整源码可以在<a href="https://github.com/xumyselfcn/sourceCode4Blog/blob/master/callable/Test.java" target="_blank" rel="external">这里</a>看到。代码中有两个类，一个TaskWithResult，实现了Callable接口，类中重写call函数；另一个Test类使用Executors.newCachedThreadPool()创建线程池。</p>
<pre><code><span class="type">ExecutorService</span> exec = <span class="type">Executors</span>.newCachedThreadPool();
<span class="type">ArrayList</span>&lt;<span class="type">Future</span>&lt;<span class="type">String</span>&gt;&gt; <span class="literal">result</span> = new <span class="type">ArrayList</span>&lt;<span class="type">Future</span>&lt;<span class="type">String</span>&gt;&gt;();
<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
    <span class="literal">result</span>.add(exec.submit(new <span class="type">TaskWithResult</span>(i)));
}

<span class="type">Future</span>的get()方法用于取出返回的值
</code></pre><p>这几行比较关键，第一行创建线程池，第二行创建了result——其类型是Future&lt;\String>，然后exec调用了submit方法创建线程，并将submit方法的返回值装入result中。这表明：</p>
<ul>
<li>使用exec.submit(new TaskWithResult(i))可以执行线程</li>
<li>submit()方法有返回值，是Future<string>类型</string></li>
</ul>
<p>那这个exec.submit()方法和exec.execute()方法有什么区别呢？进一步，实现Callable接口和Runnable接口有什么不同呢？</p>
<ul>
<li>实现Callable接口，必须重写call方法；而Runnable则对应的是run方法</li>
<li>call方法有返回值；run方法没有返回值</li>
<li>call方法可以抛出异常；run方法不能抛出异常</li>
<li>使用run方法实现的多线程，使用call方法同样可以实现</li>
</ul>
<p><strong>Callable是类似于Runnable的接口，实现Callable接口的类和实现Runnable的类都是可被其他线程执行的任务。</strong>可以看看<a href="http://www.oschina.net/question/54100_83333" target="_blank" rel="external">这里面</a>的三个实例，可以帮助理解、加深一下印象。</p>
<h2 id="究竟如何获取不同线程的返回值-Future登场">究竟如何获取不同线程的返回值-Future登场</h2>
<p>回到上面的那个例子</p>
<pre><code><span class="literal">result</span>.add(exec.submit(new <span class="type">TaskWithResult</span>(i)));
</code></pre><p>我们可以看到，在for循环里面，将每个exec.submit()方法的返回值放进了result里面。然后在后面，通过增强for循环获取每个Future，然后执行Future.get()方法获取线程返回值。</p>
<p>现在我们先来看看这个submit方法里面究竟做了什么：</p>
<pre><code><span class="comment">//根据ExecutorService exec = Executors.newCachedThreadPool();</span>
<span class="comment">//找到submit实现的位置在AbstractExecutorService类中。</span>
<span class="comment">//该类通过重载实现了三个不同的submit方法。</span>
<span class="keyword">public</span> Future&lt;?&gt; submit(Runnable <span class="keyword">task</span>) {
    <span class="keyword">if</span> (<span class="keyword">task</span> == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();
    RunnableFuture&lt;<span class="keyword">Void</span>&gt; ftask = newTaskFor(<span class="keyword">task</span>, <span class="keyword">null</span>);
    execute(ftask);
    <span class="keyword">return</span> ftask;
}
<span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; submit(Runnable <span class="keyword">task</span>, T result) {
    <span class="keyword">if</span> (<span class="keyword">task</span> == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();
    RunnableFuture&lt;T&gt; ftask = newTaskFor(<span class="keyword">task</span>, result);
    execute(ftask);
    <span class="keyword">return</span> ftask;
}
<span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; <span class="keyword">task</span>) {
    <span class="keyword">if</span> (<span class="keyword">task</span> == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();
    RunnableFuture&lt;T&gt; ftask = newTaskFor(<span class="keyword">task</span>);
    execute(ftask);
    <span class="keyword">return</span> ftask;
}
</code></pre><p>这里，我们的样例应该调用的是第三个submit函数。函数执行的过程就是：</p>
<ol>
<li>先判断task是否为null</li>
<li>创建一个ftask对象</li>
<li>执行ftask</li>
<li>返回ftask</li>
</ol>
<p>好嘛，<strong>里面其实执行线程的还是execute函数</strong>，可以印证上面的一个结论：<strong>Callable是类似于Runnable的接口，实现Callable接口的类和实现Runnable的类都是可被其他线程执行的任务，</strong>因为Callable里面其实就是用Runnable来实现创建多线程的。</p>
<p>仔细看看这三个submit函数，主要区别就在于每个submit函数的第三行，我把他们放在一起对比下：</p>
<pre><code><span class="type">RunnableFuture</span>&lt;<span class="type">Void</span>&gt; ftask = newTaskFor(task, null);
<span class="type">RunnableFuture</span>&lt;T&gt; ftask = newTaskFor(task, <span class="literal">result</span>);
<span class="type">RunnableFuture</span>&lt;T&gt; ftask = newTaskFor(task);
</code></pre><p>ftask的类型是RunnableFuture的，那这个RunnableFuture是什么呢？先别着急看答案，我们来猜一猜：</p>
<ul>
<li>RunnableFuture必然实现了Runnable接口（因为ftask可以作为execute()方法的参数）</li>
<li>RunnableFuture必然实现了Future接口（因为ftask可以作为submit()方法的返回值）</li>
</ul>
<p>欧凯，我们来看看源码：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>{
    <span class="javadoc">/**
     * Sets this Future to the result of its computation
     * unless it has been cancelled.
     */</span>
    <span class="keyword">void</span> run();
}
</code></pre><p>果然。实现Runnable接口不必多说，那这个Future接口是做什么的？</p>
<p>现在有必要介绍一下Future接口了。</p>
<pre><code>/**
 * A &lt;tt&gt;<span class="type">Future</span>&lt;/tt&gt; represents the <span class="literal">result</span> <span class="keyword">of</span> an asynchronous
 * computation.  <span class="type">Methods</span> are provided to check <span class="keyword">if</span> the computation <span class="keyword">is</span>
 * complete, to wait <span class="keyword">for</span> its completion, <span class="keyword">and</span> to retrieve the <span class="literal">result</span> <span class="keyword">of</span>
 * the computation.  <span class="type">The</span> <span class="literal">result</span> can only be retrieved <span class="keyword">using</span> <span class="keyword">method</span>
 * &lt;tt&gt;get&lt;/tt&gt; <span class="keyword">when</span> the computation has completed, blocking <span class="keyword">if</span>
 * necessary until it <span class="keyword">is</span> ready.  <span class="type">Cancellation</span> <span class="keyword">is</span> performed by the
 * &lt;tt&gt;cancel&lt;/tt&gt; <span class="keyword">method</span>.  <span class="type">Additional</span> methods are provided to
 * determine <span class="keyword">if</span> the task completed normally <span class="keyword">or</span> was cancelled. <span class="type">Once</span> a
 * computation has completed, the computation cannot be cancelled.
 * <span class="type">If</span> you would like to use a &lt;tt&gt;<span class="type">Future</span>&lt;/tt&gt; <span class="keyword">for</span> the sake
 * <span class="keyword">of</span> cancellability but <span class="keyword">not</span> provide a usable <span class="literal">result</span>, you can
 * declare types <span class="keyword">of</span> the form {@code <span class="type">Future</span>&lt;?&gt;} <span class="keyword">and</span>
 * <span class="keyword">return</span> &lt;tt&gt;null&lt;/tt&gt; <span class="keyword">as</span> a <span class="literal">result</span> <span class="keyword">of</span> the underlying task.
 * /
public <span class="keyword">interface</span> <span class="type">Future</span>&lt;V&gt; {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws <span class="type">InterruptedException</span>, <span class="type">ExecutionException</span>;
    V get(long timeout, <span class="type">TimeUnit</span> unit)
        throws <span class="type">InterruptedException</span>, <span class="type">ExecutionException</span>, <span class="type">TimeoutException</span>;
}
</code></pre><p>Future表示异步的计算结果，还提供了与之相关的一系列的函数。这里重点注意函数名为get()的两个函数。<strong>具体的Future模式在<a href="http://zha-zi.iteye.com/blog/1408189" target="_blank" rel="external">这篇文章</a>中有详细描述，一定不能错过！</strong>。</p>
<p>以下是从Future模式这个文章中摘录的：</p>
<p>Future对象本身可以看作是一个显式的引用，一个对异步处理结果的引用。由于其异步性质，在创建之初，它所引用的对象可能还并不可用（比如尚在运算中，网络传输中或等待中）。这时，得到Future的程序流程如果并不急于使用Future所引用的对象，那么它可以做其它任何想做的事儿，当流程进行到需要Future背后引用的对象时，可能有两种情况：</p>
<ul>
<li>希望能看到这个对象可用，并完成一些相关的后续流程。如果实在不可用，也可以进入其它分支流程。</li>
<li>“没有你我的人生就会失去意义，所以就算海枯石烂，我也要等到你。”（当然，如果实在没有毅力枯等下去，设一个超时也是可以理解的）</li>
</ul>
<p>对于前一种情况，可以通过调用Future.isDone()判断引用的对象是否就绪，并采取不同的处理；而后一种情况则只需调用get()或get(long timeout, TimeUnit unit)通过同步阻塞方式等待对象就绪。实际运行期是阻塞还是立即返回就取决于get()的调用时机和对象就绪的先后了。</p>
<p>简单而言，Future模式可以在连续流程中满足数据驱动的并发需求，既获得了并发执行的性能提升，又不失连续流程的简洁优雅。但是Futrue模式有个重大缺陷：当消费者工作得不够快的时候，它会阻塞住生产者线程，从而可能导致系统吞吐量的下降。所以不建议在高性能的服务端使用。</p>
<p>java.util.concurrent.Callable与java.util.concurrent.Future类可以协助您完成Future模式。<strong>Future模式在请求发生时，会先产生一个Future对象给发出请求的客户。它的作用类似于代理(Proxy)对象，而同时所代理的真正目标对象的生成是由一个新的线程持续进行。真正的目标对象生成之后，将之设置到Future之中，而当客户端真正需要目标对象时，目标对象也已经准备好，可以让客户提取使用。</strong></p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>Callable及相关源码</li>
<li><a href="http://www.cnblogs.com/whgw/archive/2011/09/28/2194760.html" target="_blank" rel="external">Callable与Future的介绍</a></li>
<li><a href="http://zha-zi.iteye.com/blog/1408189" target="_blank" rel="external">Future 模式详解（并发使用）</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="用Callable接口可以干啥">用Callable接口可以干啥</h2>
<p>简单来说，以前多线程的run方法返回值是void，那现在我想让各个线程有返回值咋办：使用Callable接口！</p>
<p>话不多说，先上例子，这个例子引自“飘过的小牛”的<a href="http://github.thinkingbar.com/thinking_in_java_chapter21-part01/" target="_blank" rel="external">这篇文章中</a>。代码如下：</p>
<pre><code>class <span class="type">TaskWithResult</span> implements <span class="type">Callable</span>&lt;<span class="type">String</span>&gt; {
    private <span class="type">int</span> id;
    public <span class="type">TaskWithResult</span>(<span class="type">int</span> id) {
        this.id = id;
    }
    //必须重写call函数
    @<span class="type">Override</span>
    public <span class="type">String</span> call() {
          <span class="keyword">return</span> <span class="string">"result of TaskWithResult: "</span> + id;
    }
}
public class <span class="type">Test</span> {
    public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) {
        <span class="type">ExecutorService</span> exec = <span class="type">Executors</span>.newCachedThreadPool();
        <span class="type">ArrayList</span>&lt;<span class="type">Future</span>&lt;<span class="type">String</span>&gt;&gt; <span class="literal">result</span> = new <span class="type">ArrayList</span>&lt;<span class="type">Future</span>&lt;<span class="type">String</span>&gt;&gt;();
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
            <span class="literal">result</span>.add(exec.submit(new <span class="type">TaskWithResult</span>(i)));
        }

        <span class="keyword">for</span>(<span class="type">Future</span>&lt;<span class="type">String</span>&gt; fs : <span class="literal">result</span>) {
            <span class="keyword">try</span> {
                <span class="type">System</span>.<span class="keyword">out</span>.println(fs.get());
            } catch (<span class="type">InterruptedException</span> | <span class="type">ExecutionException</span> e) {
                // <span class="type">TODO</span> <span class="type">Auto</span>-generated catch <span class="keyword">block</span>
                e.printStackTrace();
            } <span class="keyword">finally</span> {
                exec.shutdown();
            }
        }
    }
}
</code></pre><p>]]>
    
    </summary>
    
      <category term="java" scheme="http://blog.xumingyang.cn/tags/java/"/>
    
      <category term="Callable" scheme="http://blog.xumingyang.cn/tags/Callable/"/>
    
      <category term="Java" scheme="http://blog.xumingyang.cn/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中的final和static关键字[转]]]></title>
    <link href="http://blog.xumingyang.cn/2015/03/27/wiki/Java%E4%B8%AD%E7%9A%84final%E5%92%8Cstatic%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://blog.xumingyang.cn/2015/03/27/wiki/Java中的final和static关键字/</id>
    <published>2015-03-27T14:28:31.000Z</published>
    <updated>2015-03-29T04:39:24.000Z</updated>
    <content type="html"><![CDATA[<h1 id="关键字final">关键字final</h1>
<p>根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。</p>
<ul>
<li>final类不能被继承，没有子类，final类中的方法默认是final的。 </li>
<li>final方法不能被子类的方法覆盖，但可以被继承。 </li>
<li>final成员变量表示常量，只能被赋值一次，赋值后值不再改变。 </li>
<li>final不能用于修饰构造方法。 </li>
</ul>
<blockquote>
<p>注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。 </p>
</blockquote>
<h3 id="final类">final类</h3>
<p>final类不能被继承，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，那么就设计为final类。</p>
<h3 id="final方法">final方法</h3>
<p>如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。<br>使用final方法的原因有二： </p>
<ul>
<li>把方法锁定，防止任何继承类修改它的意义和实现。 </li>
<li>高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。 </li>
</ul>
<p>例如：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>{ 
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) { 
        <span class="comment">// TODO 自动生成方法存根 </span>
    } 
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span>() { 
        System.out.println(<span class="string">"f1"</span>); 
    } 
    <span class="comment">//无法被子类覆盖的方法 </span>
    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f2</span>() { 
        System.out.println(<span class="string">"f2"</span>); 
    } 
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f3</span>() { 
        System.out.println(<span class="string">"f3"</span>); 
    } 
    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f4</span>() { 
        System.out.println(<span class="string">"f4"</span>); 
    } 
} 

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> <span class="keyword">extends</span> <span class="title">Test1</span> </span>{ 
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span>(){ 
        System.out.println(<span class="string">"Test1父类方法f1被覆盖!"</span>); 
    } 
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) { 
        Test2 t=<span class="keyword">new</span> Test2(); 
        t.f1(); 
        t.f2(); <span class="comment">//调用从父类继承过来的final方法 </span>
        t.f3(); <span class="comment">//调用从父类继承过来的方法 </span>
        <span class="comment">//t.f4(); //调用失败，无法从父类继承获得 </span>
    } 
} 
</code></pre><h3 id="final变量（常量）">final变量（常量）</h3>
<p>用final修饰的成员变量表示常量，值一旦给定就无法改变！ final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。 从下面的例子中可以看出，一旦给final变量初值后，值就不能再改变了。另外，final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>{ 
    <span class="keyword">private</span> <span class="keyword">final</span> String S=<span class="string">"final实例变量S"</span>; 
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> A=<span class="number">100</span>; 
    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> B=<span class="number">90</span>; 

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> C=<span class="number">80</span>; 
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> D=<span class="number">70</span>; 

    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> E; <span class="comment">//final空白,必须在初始化对象的时候赋初值 </span>

    <span class="keyword">public</span> <span class="title">Test3</span>(<span class="keyword">int</span> x){ 
        E=x; 
    } 

    <span class="javadoc">/** 
    *<span class="javadoctag"> @param</span> args 
    */</span> 
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) { 
        Test3 t=<span class="keyword">new</span> Test3(<span class="number">2</span>); 
        <span class="comment">//t.A=101; //出错,final变量的值一旦给定就无法改变 </span>
        <span class="comment">//t.B=91; //出错,final变量的值一旦给定就无法改变 </span>
        <span class="comment">//t.C=81; //出错,final变量的值一旦给定就无法改变 </span>
        <span class="comment">//t.D=71; //出错,final变量的值一旦给定就无法改变 </span>

        System.out.println(t.A); 
        System.out.println(t.B); 
        System.out.println(t.C); <span class="comment">//不推荐用对象方式访问静态字段 </span>
        System.out.println(t.D); <span class="comment">//不推荐用对象方式访问静态字段 </span>
        System.out.println(Test3.C); 
        System.out.println(Test3.D); 
        <span class="comment">//System.out.println(Test3.E); //出错,因为E为final空白,依据不同对象值有所不同. </span>
        System.out.println(t.E); 

        Test3 t1=<span class="keyword">new</span> Test3(<span class="number">3</span>); 
        System.out.println(t1.E); <span class="comment">//final空白变量E依据对象的不同而不同 </span>
    } 

    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span>(){ 
        System.out.println(<span class="keyword">new</span> Test3(<span class="number">1</span>).A); 
        System.out.println(Test3.C); 
        System.out.println(Test3.D); 
    } 

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span>(){ 
        <span class="keyword">final</span> <span class="keyword">int</span> a; <span class="comment">//final空白,在需要的时候才赋值 </span>
        <span class="keyword">final</span> <span class="keyword">int</span> b=<span class="number">4</span>; <span class="comment">//局部常量--final用于局部变量的情形 </span>
        <span class="keyword">final</span> <span class="keyword">int</span> c; <span class="comment">//final空白,一直没有给赋值. </span>
        a=<span class="number">3</span>; 
        <span class="comment">//a=4; 出错,已经给赋过值了. </span>
        <span class="comment">//b=2; 出错,已经给赋过值了. </span>
    } 
} 
</code></pre><h3 id="final参数">final参数</h3>
<p>当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Test4 { 
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) { 
        <span class="keyword">new</span> Test4().f1(<span class="number">2</span>); 
    } 

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span>(final <span class="keyword">int</span> i){ 
        <span class="comment">//i++; //i是final类型的,值不允许改变的. </span>
        System.<span class="keyword">out</span>.print(i); 
    } 
} 
</code></pre><h1 id="关键字static">关键字static</h1>
<p>static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载， Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。</p>
<p>用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量。</p>
<p>static变量前可以有private修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用（当然也可以在非静态成员方法中使用—废话）， 但是不能在其他类中通过类名来直接引用，这一点很重要。实际上你需要搞明白，private是访问权限限定，static表示不要实例化就可以使用，这样 就容易理解多了。static前面加上其它访问权限关键字的效果也以此类推。 </p>
<p>static修饰的成员变量和成员方法习惯上称为静态变量和静态方法，可以直接通过类名来访问，访问语法为：</p>
<ul>
<li>类名.静态方法名(参数列表…) </li>
<li>类名.静态变量名 </li>
</ul>
<p>用static修饰的代码块表示静态代码块，当Java虚拟机（JVM）加载类时，就会执行该代码块（用处非常大，呵呵）。 </p>
<h3 id="static变量">static变量</h3>
<p>按照是否静态的对类成员变量进行分类可分两种：一种是被static修饰的变量，叫静态变量或类变量；另一种是没有被static修饰的变量，叫实例变量。两者的区别是： </p>
<ul>
<li>对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。 </li>
<li>对于实例变量，每创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。 </li>
</ul>
<h3 id="静态方法">静态方法</h3>
<p>静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。因为实例成员与特定的对象关联！因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。</p>
<h3 id="static代码块">static代码块</h3>
<p>static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。例如：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Test5 { 
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a; 
    <span class="keyword">private</span> <span class="keyword">int</span> b; 

    <span class="keyword">static</span>{ 
        Test5.a=<span class="number">3</span>; 
        System.<span class="keyword">out</span>.println(a); 
        Test5 t=<span class="keyword">new</span> Test5(); 
        t.f(); 
        t.b=<span class="number">1000</span>; 
        System.<span class="keyword">out</span>.println(t.b); 
    } 
    <span class="keyword">static</span>{ 
        Test5.a=<span class="number">4</span>; 
        System.<span class="keyword">out</span>.println(a); 
    } 
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) { 
        <span class="comment">// TODO 自动生成方法存根 </span>
    } 
    <span class="keyword">static</span>{ 
        Test5.a=<span class="number">5</span>; 
        System.<span class="keyword">out</span>.println(a); 
    } 
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span>(){ 
        System.<span class="keyword">out</span>.println(<span class="string">"hhahhahah"</span>); 
    } 
} 

<span class="comment">//程序输出</span>
<span class="number">3</span> 
hhahhahah 
<span class="number">1000</span> 
<span class="number">4</span> 
<span class="number">5</span> 
</code></pre><h3 id="static和final一块用表示什么">static和final一块用表示什么</h3>
<p>static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！</p>
<ul>
<li>对于变量，表示一旦给值就不可修改，并且通过类名可以访问。 </li>
<li>对于方法，表示不可覆盖，并且可以通过类名直接访问。</li>
</ul>
<p>本文转载自：<a href="http://www.blogjava.net/hongzionline/archive/2007/09/19/146392.html" target="_blank" rel="external">java—-final 关键字 和 static 用法</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="关键字final">关键字final</h1>
<p>根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。</p>
<ul>
<li>fina]]>
    </summary>
    
      <category term="java final static" scheme="http://blog.xumingyang.cn/tags/java-final-static/"/>
    
      <category term="Java" scheme="http://blog.xumingyang.cn/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java序列化]]></title>
    <link href="http://blog.xumingyang.cn/2015/03/27/Java%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://blog.xumingyang.cn/2015/03/27/Java序列化/</id>
    <published>2015-03-27T14:28:31.000Z</published>
    <updated>2015-04-15T08:58:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="序列化的相关知识点">序列化的相关知识点</h2>
<p>先看这三个知识点</p>
<ul>
<li>将对象转换为字节流保存起来，并在以后还原这个对象，这种机制叫做<code>(对象)序列化</code>。</li>
<li>将一个对象保存到永久存储设备上称为<code>持久化</code>。</li>
<li>一个对象要想能够实现序列化，必须实现<code>Serializable</code>接口或<code>Externalizable</code>接口。</li>
</ul>
<blockquote>
<p>比如内存里面有Person这样一个对象，这个对象已经new出来了，接下来我把这个对象保存到文件里面，因为内存里面的东西一旦java虚拟机关闭了就都没有了，所以保存到文件里面，保存到文件之后，等到下一次java虚拟机再次起来之后，我再把这个Person对象从文件里面读取回来，再加载到内存中，这就是序列化。<strong>必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量。</strong></p>
</blockquote>
<p>好了，如果您是初次接触序列化，建议您先看一下<a href="http://www.w3cschool.cc/java/java-serialization.html" target="_blank" rel="external">这个入门的小例子</a>~</p>
<p>Serializable是一个<code>标记接口</code>(maker interface)，关于标记接口可以参考<a href="http://blog.xumingyang.cn/2015/03/23/RandomAccess%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">这篇文章</a>。若某个类实现了Serializable接口，编译器就知道这个类是可以序列化的；否则，序列化一个没有实现该接口的对象，会抛出NotSerializableException异常。</p>
<p>这里需要厘清<code>序列化</code>和<code>持久化</code>的概念，下面是一些关于序列化/持久化的说法：</p>
<p><a href="http://www.zhihu.com/people/xu-chen-5" target="_blank" rel="external">徐辰</a></p>
<blockquote>
<p>对象持久化就是让对象的生存期超越使用对象的程序的运行期，简单说就是save&amp;load</p>
</blockquote>
<p><a href="http://www.zhihu.com/people/lsun" target="_blank" rel="external">孙立伟</a></p>
<blockquote>
<ul>
<li>对象持久化就是将对象存储在可持久保存的存储介质上，例如主流的关系数据库中。在实际应用中，需要将业务数据以对象的方式保存在数据库中，就需要应用到相应的对象持久化框架，如现在广为认知的Hibernate。而如果查阅对象持久化的历史，你会发现早在1970年就已经开始有称之为面向对象数据库OODBMS。通常这些面向对象的数据库和特定的一种语言绑定。对象持久化的重点在于如何将业务数据对象存储在持久化介质上，并同时提供查询修改的手段。</li>
<li>数据序列化就是将对象或者数据结构转化成特定的格式，使其可在网络中传输，或者可存储在内存或者文件中。反序列化则是相反的操作，将对象从序列化数据中还原出来。而对象序列化后的数据格式可以是二进制，可以是XML，也可以是JSON等任何格式。对象/数据序列化的重点在于数据的交换和传输，例如在远程调用技术(如EJB,XML-RPC, Web Service)，或者在GUI控件开发(JavaBean)等等。</li>
</ul>
<p>总结一下：对象持久化和对象序列化是两个完全不同的应用场景，尽管你也可以说将一个对象序列化后存储在数据库中，但是你也不能说是对象持久化。</p>
</blockquote>
<p><a href="http://www.zhihu.com/people/liang-chuan" target="_blank" rel="external">梁川</a></p>
<blockquote>
<p>一个轻量级，一个重量级。</p>
<ul>
<li>持久化往往依赖于数据库，是为了长期存储的。</li>
<li>序列化是为了散集和列集做短期存储和数据传递的。</li>
</ul>
</blockquote>
<p>我觉得最开始的知识点里面描述的很到位：</p>
<ul>
<li>序列化就是把对象转化成字节流，以备后面再使用反序列化还原对象。</li>
<li>持久化则是把对象保存起来。</li>
</ul>
<h2 id="序列化的实现">序列化的实现</h2>
<h3 id="使用Java内置的序列化方式：">使用Java内置的序列化方式：</h3>
<ul>
<li>如果需要让某个对象可以支持序列化机制，必须让它的类是可序列化（serializable），为了让某个类可序列化的，必须实现如下两个接口之一： Serializable，Externalizable。</li>
<li>所有在网络上传输的对象都应该是可序列化的，否则将会出现异常；所有需要保存到磁盘里的对象的类都必须可序列化。（通常建议：程序创建的每个JavaBean类都实现Serializable)</li>
</ul>
<h3 id="其他序列化方式">其他序列化方式</h3>
<p>有时候Java内置的序列化方式并不能满足我们的需求，因此又有了其他的序列化方式，具体请看<code>序列化协议&amp;框架</code>部分。</p>
<h2 id="影响序列化的因素">影响序列化的因素</h2>
<h3 id="transient关键字">transient关键字</h3>
<p>当某个字段被声明为transient后，默认序列化机制就会忽略该字段。</p>
<h3 id="writeObject()方法与readObject()方法">writeObject()方法与readObject()方法</h3>
<p>如果实现了Serializable接口的对象重写了writeObject方法，则该对象的序列化操作就交给了该函数。一般还要相应的实现readObject方法。</p>
<p>必须注意地是，writeObject()与readObject()都是private方法，那么它们是如何被调用的呢？毫无疑问，是使用反射。详情可见ObjectOutputStream中的writeSerialData方法，以及ObjectInputStream中的readSerialData方法。</p>
<blockquote>
<p>一般在集合类中，都会把存储数据的数组（或Node节点）设置为transient，然后重写writeObject和readObject方法。这是因为那些数组（或Node节点）里面存储的可能并不是原生类型，而是堆上对象的引用地址，那么我们如果直接把这些地址进行序列化操作是毫无意义的，所以需要重写writeObject和readObject方法。</p>
</blockquote>
<h3 id="Externalizable接口">Externalizable接口</h3>
<p>无论是使用transient关键字，还是使用writeObject()和readObject()方法，其实都是基于Serializable接口的序列化。JDK中提供了另一个序列化接口—Externalizable，使用该接口之后，之前基于Serializable接口的序列化机制就将失效。</p>
<p>Externalizable继承于Serializable，当使用该接口时，序列化的细节需要由程序员去完成。如果writeExternal()与readExternal()方法未作任何处理，那么该序列化行为将不会保存/读取任何一个字段，输出结果中所有字段的值均为空。</p>
<p>另外，若使用Externalizable进行序列化，当读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。实现Externalizable接口的类必须要提供一个无参的构造器，且它的访问权限为public。</p>
<h3 id="readResolve()方法">readResolve()方法</h3>
<p>当我们使用Singleton模式时，应该是期望某个类的实例应该是唯一的，但如果该类是可序列化的，那么情况可能会略有不同，因为我们不希望在反序列化时生成多个对象。</p>
<p>无论是实现Serializable接口，或是Externalizable接口，当从I/O流中读取对象时，readResolve()方法都会被调用到。实际上就是用readResolve()中返回的对象直接替换在反序列化过程中创建的对象，而被创建的对象则会被垃圾回收掉。</p>
<h3 id="serialVersionUID">serialVersionUID</h3>
<p><strong>SerialVersionUid</strong>，简言之，其目的是序列化对象版本控制，有关各版本反序列化时是否兼容。如果在新版本中这个值修改了，新版本就不兼容旧版本，反序列化时会抛出<strong>InvalidClassException</strong>异常。如果修改较小，比如仅仅是增加了一个属性，我们希望向下兼容，老版本的数据都能保留，那就不用修改；如果我们删除了一个属性，或者更改了类的继承关系，必然不兼容旧数据，这时就应该手动更新版本号，即<strong>SerialVersionUid</strong>。</p>
<p>更加详细的关于serialVersionUID的讲解可以在<a href="http://blog.csdn.net/fbysss/article/details/5844478" target="_blank" rel="external">这篇文章</a>里面见到。</p>
<h2 id="序列化协议&amp;框架">序列化协议&amp;框架</h2>
<h3 id="序列化协议">序列化协议</h3>
<ul>
<li>XML</li>
<li>JSON</li>
<li>Protobuf</li>
<li>Thrift</li>
<li>Avro</li>
</ul>
<p>更多的关于序列化协议的介绍可以看<a href="http://tech.meituan.com/serialization_vs_deserialization.html" target="_blank" rel="external">序列化和反序列化</a></p>
<h3 id="序列化框架:">序列化框架:</h3>
<ul>
<li>Kryo</li>
<li>Hessian</li>
<li>Protostuff</li>
<li>Protostuff-Runtime</li>
<li>Java</li>
</ul>
<p>更多的关于序列化框架的介绍可以看<a href="http://x-rip.iteye.com/blog/1555293" target="_blank" rel="external">序列化框架 kryo VS hessian VS Protostuff VS java</a>。</p>
<h2 id="序列化中需要注意的地方">序列化中需要注意的地方</h2>
<ul>
<li>当一个对象被序列化时，只保存对象的非静态成员变量，不能保存任何的成员方法和静态的成员变量。 </li>
<li>如果一个对象的成员变量是一个对象，那么这个对象的数据成员也会被保存。</li>
<li>如果一个可序列化的对象包含对某个不可序列化的对象的引用，那么整个序列化操作将会失败，我们可以将这个对象引用标记为transient，那么对象仍然可以序列化。</li>
<li>如果我们向文件中使用序列化机制写入了多个Java对象，使用反序列化机制恢复对象必须按照实际写入的顺序读取。 </li>
<li>当一个可序列化类有多个父类时（包括直接父类和间接父类），这些父类要么有无参的构造器，要么也是可序列化的—否则反序列化将抛出InvalidClassException异常。如果父类是不可序列化的，只是带有无参数的构造器，则该父类定义的Field值不会被序列化到二进制流中。</li>
<li>序列化和反序列化时所用的类必须一致。比较两个类是否“相等”，只有在这两个类是由<code>同一个类加载器</code>加载的前提下才有意义，否则，即使这两类是来源于同一个Class文件，只要加载他们的类加载器不用，那这两个类就必定不相等。<blockquote>
<p>这里所指的”相等”，包括代表类的 Class 对象的 equals()方法、 isAssignableFrom()方法、 islnstance()方法的返回结果，也包括了使用 instanceof 关键字做对象所属关系判定等情况 。</p>
</blockquote>
</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://www.w3cschool.cc/java/java-serialization.html" target="_blank" rel="external">Java序列化(这里提供了一个最基础的示例)</a></li>
<li><a href="http://www.zhihu.com/question/20706270" target="_blank" rel="external">什么是对象持久化，与数据序列化有何联系？(来自知乎)</a></li>
<li><a href="http://fangguanhong.iteye.com/blog/1976911" target="_blank" rel="external">“java对象序列化与对象反序列化”深入详解</a></li>
<li><a href="http://www.blogjava.net/jiangshachina/archive/2012/02/13/369898.html" target="_blank" rel="external">理解Java对象序列化</a></li>
<li><a href="http://developer.51cto.com/art/200908/147650.htm" target="_blank" rel="external">Java序列化的机制和原理</a></li>
<li><a href="http://blog.csdn.net/fbysss/article/details/5844478" target="_blank" rel="external">深入理解Java序列化中的SerialVersionUid</a></li>
</ul>
<h2 id="扩展阅读">扩展阅读</h2>
<ul>
<li><a href="http://tech.meituan.com/serialization_vs_deserialization.html" target="_blank" rel="external">序列化和反序列化(来自美团技术博客)</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-lo-serial/" target="_blank" rel="external">Java序列化的高级认识</a></li>
<li><a href="http://tangyongjunbk.blog.163.com/blog/static/128389013201082481625255/" target="_blank" rel="external">如何生成一个SerialVersionUID</a></li>
<li><a href="http://lenjey.iteye.com/blog/513736" target="_blank" rel="external">对象序列化为何要定义serialVersionUID的来龙去脉</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="序列化的相关知识点">序列化的相关知识点</h2>
<p>先看这三个知识点</p>
<ul>
<li>将对象转换为字节流保存起来，并在以后还原这个对象，这种机制叫做<code>(对象)序列化</code>。</li>
<li>将一个对象保存到永久存储设备上称为<c]]>
    </summary>
    
      <category term="java" scheme="http://blog.xumingyang.cn/tags/java/"/>
    
      <category term="序列化" scheme="http://blog.xumingyang.cn/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="Java" scheme="http://blog.xumingyang.cn/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[源码浅析-使用ThreadPoolExecutor创建线程池-以Executors提供的几种方式为例]]></title>
    <link href="http://blog.xumingyang.cn/2015/03/26/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor/"/>
    <id>http://blog.xumingyang.cn/2015/03/26/Java线程池ThreadPoolExecutor/</id>
    <published>2015-03-26T14:28:31.000Z</published>
    <updated>2015-03-28T13:43:31.000Z</updated>
    <content type="html"><![CDATA[<p>ThreadPoolExecutor类是用来创建线程池的类，通常使用Executors里面的静态方法来创建（Executors类似于）。线程池负责管理工作线程，包含一个等待执行的任务队列。线程池的任务队列是一个Runnable集合，工作线程负责从任务队列中取出并执行Runnable对象。</p>
<p>java.util.concurrent.executors 提供了 java.util.concurrent.executor 接口的一个Java实现，可以创建线程池。常见的用法如下：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
        System.out.println(<span class="string">"打印机工作"</span>);
        TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>{
    ExecutorService exec = Executors.newCachedThreadPool();
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {
        exec.execute(<span class="keyword">new</span> Printer());
    }
    exec.shutdown();
}
</code></pre><p><a id="more"></a><br>我们拿到一个 ExecutorService 来管理所有的 Thread 对象，在执行完所有的任务后，只需要调用一个 shutdown()即可关闭所有管理的 Thread 对象。这里面我们用的是Executors.newCachedThreadPool()，除此之外，还有另外几种常用的线程池：</p>
<ul>
<li>固定工作线程数量的线程池：Executors.newFixedThreadPool()</li>
<li>一个可缓存的线程池：Executors.newCachedThreadPool()</li>
<li>单线程化的Executor：Executors.newSingleThreadExecutor()</li>
<li>支持定时的以及周期性的任务执行：Executors.newScheduledThreadPool()</li>
</ul>
<p>主要就是上面那四种，值得注意的是，<strong>这几种线程池的任务队列各不相同</strong>。关于缓冲队列也就是下面构造函数中的形参workQueue的官方英文解释是：</p>
<blockquote>
<p>workQueue: the queue to use for holding tasks before they are executed. This queue will hold only the {@code Runnable} tasks submitted by the {@code execute} method.</p>
</blockquote>
<ul>
<li>newFixedThreadPool使用的是LinkedBlockingQueue</li>
<li>newCachedThreadPool使用的是SynchronousQueue</li>
<li>newSingleThreadExecutor使用的是LinkedBlockingQueue</li>
<li>newScheduledThreadPool使用的是DelayedWorkQueue</li>
</ul>
<p>这些队列有什么区别呢？我现在也不清楚，明天好好整理整理。</p>
<p>下面这些是Executors里面给我们定义好的几种线程池，我们可以根据实际情况进行使用，如果都不满足的话，可以自己创建ThreadPoolExecutor，可以更加灵活的设置各种构造参数。</p>
<p><img src="http://xumyselfcn.github.io/imgs/newThreadPool.png" alt=""></p>
<p>我们如果看Executors的源码的话，可以发现，上述Executors的四个构造线程池的方法内部都是返回一个新建的ThreadPoolExecutor类，所以我们直接研究ThreadPoolExecutor的构造函数就可以明白Executors创建线程池的原理。</p>
<pre><code>    <span class="comment">//ThreadPoolExecutor的构造函数</span>
    <span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span>(<span class="keyword">int</span> corePoolSize,
        <span class="keyword">int</span> maximumPoolSize,
        <span class="keyword">long</span> keepAliveTime,
        TimeUnit unit,
        BlockingQueue&lt;Runnable&gt; workQueue，
        ThreadFactory threadFactory,
        RejectedExecutionHandler handler) {
        <span class="keyword">this</span>(....);<span class="comment">//调用本地的构造函数</span>
    }
</code></pre><p>先解释在上述的构造函数中出现的几个形参：</p>
<ul>
<li>corePoolSize：线程池维护线程的最少数量</li>
<li>maximumPoolSize：线程池维护线程的最大数量</li>
<li>keepAliveTime：线程池维护线程所允许的空闲时间</li>
<li>unit： 线程池维护线程所允许的空闲时间的单位，unit可选的参数为java.util.concurrent.TimeUnit中的几个静态属性：<ul>
<li>NANOSECONDS</li>
<li>MICROSECONDS</li>
<li>MILLISECONDS</li>
<li>SECONDS</li>
</ul>
</li>
<li>workQueue：线程池所使用的缓冲队列，常用的是：java.util.concurrent.ArrayBlockingQueue</li>
<li>threadFactory：创建新线程时，使用的线程工厂</li>
<li>handler： 线程池对拒绝任务的处理策略，有四个选择如下：<ul>
<li>ThreadPoolExecutor.AbortPolicy()：抛出java.util.concurrent.RejectedExecutionException异常</li>
<li>ThreadPoolExecutor.CallerRunsPolicy()：重试添加当前的任务，他会自动重复调用execute()方法</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy()：抛弃旧的任务</li>
<li>ThreadPoolExecutor.DiscardPolicy()：抛弃当前的任务</li>
</ul>
</li>
</ul>
<p>当一个任务通过execute(Runnable)方法想添加线程到线程池时： </p>
<ul>
<li>如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。</li>
<li>如果此时线程池中的数量等于 corePoolSize，但是缓冲队列 workQueue未满，那么任务被放入缓冲队列。</li>
<li>如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。</li>
<li>如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于 maximumPoolSize，那么通过 handler所指定的策略来处理此任务。也就是：处理任务的优先级为：核心线程corePoolSize、任务队列workQueue、最大线程 maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。</li>
<li>当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。</li>
</ul>
<p>下面我们看看ThreadPoolExecutor的execute方法，中间的注释描述的跟上面这段意思差不多。</p>
<pre><code>public void execute(Runnable command) {
    <span class="keyword">if</span> (command == null)
        throw new NullPointerException();
    /*
     * Proceed <span class="keyword">in</span> <span class="number">3</span> steps:
     *
     * <span class="number">1.</span> If fewer than corePoolSize threads are <span class="property">running</span>, <span class="keyword">try</span> <span class="keyword">to</span>
     * start a new thread <span class="keyword">with</span> <span class="keyword">the</span> <span class="keyword">given</span> command <span class="keyword">as</span> <span class="keyword">its</span> <span class="keyword">first</span>
     * task.  The call <span class="keyword">to</span> addWorker atomically checks runState <span class="keyword">and</span>
     * workerCount, <span class="keyword">and</span> so prevents <span class="constant">false</span> alarms <span class="keyword">that</span> would add
     * threads when <span class="keyword">it</span> shouldn't, <span class="keyword">by</span> <span class="keyword">returning</span> <span class="constant">false</span>.
     *
     * <span class="number">2.</span> If a task can be successfully queued, <span class="keyword">then</span> we still need
     * <span class="keyword">to</span> double-check whether we should have added a thread
     * (because existing ones died <span class="keyword">since</span> <span class="keyword">last</span> checking) <span class="keyword">or</span> <span class="keyword">that</span>
     * <span class="keyword">the</span> pool shut down <span class="keyword">since</span> entry <span class="keyword">into</span> this method. So we
     * recheck state <span class="keyword">and</span> <span class="keyword">if</span> necessary roll <span class="keyword">back</span> <span class="keyword">the</span> enqueuing <span class="keyword">if</span>
     * stopped, <span class="keyword">or</span> start a new thread <span class="keyword">if</span> there are none.
     *
     * <span class="number">3.</span> If we cannot queue task, <span class="keyword">then</span> we <span class="keyword">try</span> <span class="keyword">to</span> add a new
     * thread.  If <span class="keyword">it</span> fails, we know we are shut down <span class="keyword">or</span> saturated
     * <span class="keyword">and</span> so reject <span class="keyword">the</span> task.
     */
    int c = ctl.<span class="keyword">get</span>();
    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) {
        <span class="keyword">if</span> (addWorker(command, <span class="constant">true</span>))
<span class="command">            return</span>;
        c = ctl.<span class="keyword">get</span>();
    }
    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) {
        int recheck = ctl.<span class="keyword">get</span>();
        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))
            reject(command);
        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)
            addWorker(null, <span class="constant">false</span>);
    }
    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="constant">false</span>))
        reject(command);
}
</code></pre><h2 id="参考资料">参考资料</h2>
<ul>
<li>Executors、ThreadPoolExecutor源码</li>
<li><a href="http://my.oschina.net/linuxred/blog/27924" target="_blank" rel="external">Java线程池ThreadPoolExecutor</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>ThreadPoolExecutor类是用来创建线程池的类，通常使用Executors里面的静态方法来创建（Executors类似于）。线程池负责管理工作线程，包含一个等待执行的任务队列。线程池的任务队列是一个Runnable集合，工作线程负责从任务队列中取出并执行Runnable对象。</p>
<p>java.util.concurrent.executors 提供了 java.util.concurrent.executor 接口的一个Java实现，可以创建线程池。常见的用法如下：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
        System.out.println(<span class="string">"打印机工作"</span>);
        TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>{
    ExecutorService exec = Executors.newCachedThreadPool();
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {
        exec.execute(<span class="keyword">new</span> Printer());
    }
    exec.shutdown();
}
</code></pre><p>]]>
    
    </summary>
    
      <category term="java" scheme="http://blog.xumingyang.cn/tags/java/"/>
    
      <category term="多线程" scheme="http://blog.xumingyang.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://blog.xumingyang.cn/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[源码浅析-LinkedList详解]]></title>
    <link href="http://blog.xumingyang.cn/2015/03/25/LinkedList%E8%AF%A6%E8%A7%A3/"/>
    <id>http://blog.xumingyang.cn/2015/03/25/LinkedList详解/</id>
    <published>2015-03-26T01:28:31.000Z</published>
    <updated>2015-04-03T09:12:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>LinkedList是一个双向链表，继承自AbstractSequentialList类，实现了List、Deque、Cloneable和Serializable接口。</p>
<pre><code><span class="comment">//java version "1.7.0_40"</span>
<span class="comment">//Java(TM) SE Runtime Environment (build 1.7.0_40-b43)</span>
<span class="comment">//Java HotSpot(TM) Client VM (build 24.0-b56, mixed mode, sharing)</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;
    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;
    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>{
    ...
}
</code></pre><p>对比上一篇<a href="http://blog.xumingyang.cn/2015/03/27/ArrayList%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">ArrayList详解</a> ，我们已经可以大概得知LinkedList有哪些特性了：是线性存储、可以当队列使用、可以调用clone方法、可以序列化。<br><a id="more"></a></p>
<h2 id="特性">特性</h2>
<ul>
<li>LinkedList是双向链表</li>
<li>实现 Queue 接口，提供先进先出队列操作</li>
<li>在列表的开头及结尾 get、remove和insert元素提供了统一的命名方法，这些操作允许将链接列表用作堆栈、队列或双端队列 (deque)</li>
<li>clone、modCount和序列化的情况同ArrayList一致</li>
</ul>
<h2 id="详解">详解</h2>
<h3 id="1、双向链表">1、双向链表</h3>
<pre><code><span class="keyword">transient</span> <span class="keyword">int</span> <span class="keyword">size</span> = <span class="number">0</span>;
<span class="keyword">transient</span> Node&lt;E&gt; first;
<span class="keyword">transient</span> Node&lt;E&gt; last;
</code></pre><p>从其属性定义看，一个指向头结点，一个指向尾节点，这里的Node是LinkedList的一个内部类：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> Node&lt;E&gt; {
    E item;
    Node&lt;E&gt; <span class="keyword">next</span>;
    Node&lt;E&gt; prev;

    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; <span class="keyword">next</span>) {
        <span class="keyword">this</span>.item = element;
        <span class="keyword">this</span>.<span class="keyword">next</span> = <span class="keyword">next</span>;
        <span class="keyword">this</span>.prev = prev;
    }
}
</code></pre><h3 id="实现Queue接口">实现Queue接口</h3>
<p>其实LinkedList不仅可以拿来当Queue使用，也可以当Stack使用，因为它是双向链表！其内部提供的方法有：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span>(E e) 
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span>(E e) 
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span>(E e) 
<span class="keyword">public</span> E <span class="title">get</span>(<span class="keyword">int</span> index) 
<span class="keyword">public</span> E <span class="title">getFirst</span>() 
<span class="keyword">public</span> E <span class="title">getLast</span>() 
<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span>(E e) 
<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span>(E e) 
<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span>(E e) 
<span class="keyword">public</span> E <span class="title">peek</span>() 
<span class="keyword">public</span> E <span class="title">peekFirst</span>() 
<span class="keyword">public</span> E <span class="title">peekLast</span>() 
<span class="keyword">public</span> E <span class="title">poll</span>() 
<span class="keyword">public</span> E <span class="title">pollFirst</span>() 
<span class="keyword">public</span> E <span class="title">pollLast</span>() 
<span class="keyword">public</span> E <span class="title">pop</span>() 
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span>(E e) 
<span class="keyword">public</span> E <span class="title">remove</span>() 
<span class="keyword">public</span> E <span class="title">removeFirst</span>() 
<span class="keyword">public</span> E <span class="title">removeLast</span>() 
<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span>() 
</code></pre><p>队列和栈需要的方法全部都提供了</p>
<h3 id="其他">其他</h3>
<ol>
<li>LinkedList有两个内部类：ListItr和DescendingIterator，分别用来提供正向（从first到last）迭代器和反向（从last到first）迭代器。</li>
<li>remove(int)和remove(Object)的时间复杂度都是O(n)，因为需要先找到那个int 值/Object对象。</li>
</ol>
<h2 id="LinkedList和ArrayList的区别、联系">LinkedList和ArrayList的区别、联系</h2>
<p>相同点是两者都实现了List, Cloneable, Serializable接口，两者都是线性集合，都可以克隆，序列化。</p>
<p>ArrayList 采用的是数组形式来保存对象的，这种方式将对象放在连续的位置中，所以最大的缺点就是插入删除时非常麻烦，优点是查询速度快</p>
<p>LinkedList 采用的将对象存放在独立的空间中，而且在每个空间中还保存下一个链接的索引，但是缺点就是查找非常麻烦，要丛第一个索引开始，优点是插入、删除快。</p>
<p>更详细的可以参考<a href="http://www.importnew.com/6629.html" target="_blank" rel="external">这篇</a></p>
<p>下面是Java Collection Framework框架图，点击可放大。<br><img src="http://blog.xumingyang.me/imgs/java-collection.jpg" alt="Collection FrameWork"></p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>LinkedList源码</li>
<li><a href="http://www.importnew.com/6629.html" target="_blank" rel="external">LinkedList和ArrayList的区别</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="概述">概述</h2>
<p>LinkedList是一个双向链表，继承自AbstractSequentialList类，实现了List、Deque、Cloneable和Serializable接口。</p>
<pre><code><span class="comment">//java version "1.7.0_40"</span>
<span class="comment">//Java(TM) SE Runtime Environment (build 1.7.0_40-b43)</span>
<span class="comment">//Java HotSpot(TM) Client VM (build 24.0-b56, mixed mode, sharing)</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;
    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;
    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>{
    ...
}
</code></pre><p>对比上一篇<a href="http://blog.xumingyang.cn/2015/03/27/ArrayList%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">ArrayList详解</a> ，我们已经可以大概得知LinkedList有哪些特性了：是线性存储、可以当队列使用、可以调用clone方法、可以序列化。<br>]]>
    
    </summary>
    
      <category term="java" scheme="http://blog.xumingyang.cn/tags/java/"/>
    
      <category term="容器" scheme="http://blog.xumingyang.cn/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="Java" scheme="http://blog.xumingyang.cn/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RandomAccess详解]]></title>
    <link href="http://blog.xumingyang.cn/2015/03/23/RandomAccess%E8%AF%A6%E8%A7%A3/"/>
    <id>http://blog.xumingyang.cn/2015/03/23/RandomAccess详解/</id>
    <published>2015-03-23T14:28:31.000Z</published>
    <updated>2015-03-28T09:13:09.000Z</updated>
    <content type="html"><![CDATA[<p>RandomAccess、Cloneable、Serializable都是标记接口（maker interface），所谓标记接口不会在其内部定义方法，实现标记接口的类表明该类拥有一种特殊的能力。</p>
<p>比如实现RandomAccess接口的ArrayList有快速随机访问的能力，Cloneable、Serializable与之类似。其实ArrayList的各种特性就是AbstractList、RandomAccess、Cloneable、Serializable几种接口特性的叠加。</p>
<a id="more"></a>

<blockquote>
<p>RandomAccess is a marker interface, like the Serializable and Cloneable interfaces. All of these marker interfaces do not define methods; instead, they identify a class as having a particular capability.</p>
</blockquote>
<p>实现了maker interface的类有什么神奇的作用呢？</p>
<p>实现了Serializable接口的类的对象，在序列化的时候不会抛出NotSerializableException异常了（除非这个对象还包含其他未实现Serializable接口的内部类）；实现了Cloneable接口的类的对象，在使用clone()方法时，不会抛出CloneNotSupportedException异常了。</p>
<blockquote>
<p>In the case of Serializable, the interface specifies that if the class is serialized using the serialization I/O classes, then a NotSerializableException will not be thrown (unless the object contains some other class that cannot be serialized). Cloneable similarly indicates that the use of the Object.clone() method for a Cloneable class will not throw a CloneNotSupportedException.</p>
</blockquote>
<p>其实，RandomAccess跟上述两个接口有点区别的。实现RandomAccess接口的集合类意味着：List.get()方法的执行速度会比Iterator.next()方法速度快。 </p>
<blockquote>
<p>The RandomAccess interface identifies that a particular java.util.List implementation has fast random access. A more accurate name for the interface would have been FastRandomAccess. This interface tries to define an imprecise concept: how fast is fast? The documentation provides a simple guide: if repeated access using the List.get() method is faster than repeated access using the Iterator.next() method, then the List has fast random access. </p>
</blockquote>
<p>关于RandomAccess的一个用法：</p>
<pre><code><span class="keyword">if</span> (listObject instanceof <span class="type">RandomAccess</span>)
{
  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, n=list.size(); i &lt; n; i++)
  {
    o = list.get(i);
    //<span class="keyword">do</span> something <span class="keyword">with</span> <span class="keyword">object</span> o
  }

}
<span class="keyword">else</span>
{
  <span class="type">Iterator</span> itr = list.<span class="keyword">iterator</span>();
  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, n=list.size(); i &lt; n; i++)
  {
    o = itr.next();
    //<span class="keyword">do</span> something <span class="keyword">with</span> <span class="keyword">object</span> o

  }
}
</code></pre><p>先判断这个对象是不是实现了RandomAccess的接口，如果是，那么就采用get()方法进行遍历；否则就使用迭代器进行遍历。</p>
<h3 id="参考资料">参考资料</h3>
<ul>
<li><a href="http://www.onjava.com/pub/a/onjava/2001/10/23/optimization.html" target="_blank" rel="external">Interface RandomAccess</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>RandomAccess、Cloneable、Serializable都是标记接口（maker interface），所谓标记接口不会在其内部定义方法，实现标记接口的类表明该类拥有一种特殊的能力。</p>
<p>比如实现RandomAccess接口的ArrayList有快速随机访问的能力，Cloneable、Serializable与之类似。其实ArrayList的各种特性就是AbstractList、RandomAccess、Cloneable、Serializable几种接口特性的叠加。</p>
]]>
    
    </summary>
    
      <category term="java" scheme="http://blog.xumingyang.cn/tags/java/"/>
    
      <category term="maker" scheme="http://blog.xumingyang.cn/tags/maker/"/>
    
      <category term="interface" scheme="http://blog.xumingyang.cn/tags/interface/"/>
    
      <category term="Java" scheme="http://blog.xumingyang.cn/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[源码分析-ArrayList详解]]></title>
    <link href="http://blog.xumingyang.cn/2015/03/23/ArrayList%E8%AF%A6%E8%A7%A3/"/>
    <id>http://blog.xumingyang.cn/2015/03/23/ArrayList详解/</id>
    <published>2015-03-23T14:28:31.000Z</published>
    <updated>2015-03-28T09:13:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>ArrayList是List、RandomAccess、Cloneable、Serializable接口的可变长数组实现。与Vector的最大区别就是没用使用Synchronized关键字进行同步。不过ArrayList对writeObject和readObject两个方法进行了同步。</p>
<pre><code><span class="comment">//java version "1.7.0_40"</span>
<span class="comment">//Java(TM) SE Runtime Environment (build 1.7.0_40-b43)</span>
<span class="comment">//Java HotSpot(TM) Client VM (build 24.0-b56, mixed mode, sharing)</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;
    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, 
    <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>{
    ...
}
</code></pre><p>其实ArrayList的各种特性就是AbstractList、RandomAccess、Cloneable、Serializable几种接口特性、当然还有它自己的特性的叠加(这几个都是maker interface，具体见这里)。<br><a id="more"></a></p>
<h2 id="特性">特性</h2>
<ul>
<li>顺序存储</li>
<li>默认初始大小为10，不够则扩容至原来的1.5倍(oldCapacity + (oldCapacity &gt;&gt; 1)),如果在已知大小的情况下，最好使用public ArrayList(int initialCapacity)构造函数进行初始化。</li>
<li>使用modCount、expectedModCount机制规避风险（这个是AbstractList接口的特性）</li>
<li>clone方法用于返回一个当前List的引用，使用时注意避免浅拷贝。Returns a shallow copy of this ArrayList instance.  (The elements themselves are not copied.)</li>
<li>实现writeObject和readObject方法用于序列化</li>
</ul>
<h2 id="详解">详解</h2>
<p>如下是ArrayList成员对象的定义</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;
<span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;
<span class="keyword">private</span> <span class="keyword">int</span> size;
</code></pre><h3 id="1、Add方法、自动扩充和modCount">1、Add方法、自动扩充和modCount</h3>
<p>数据存储在Object数组中，默认初始大小是10，size存储当前List的长度。ArrayList的主要方法：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span>(E e) {
    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span>
    elementData[size++] = e;
    <span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span>(<span class="keyword">int</span> minCapacity) {
    <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) {
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }

    ensureExplicitCapacity(minCapacity);
}

<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span>(<span class="keyword">int</span> minCapacity) {
    modCount++;

    <span class="comment">// overflow-conscious code</span>
    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)
        grow(minCapacity);
}

<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span>(<span class="keyword">int</span> minCapacity) {
    <span class="comment">// overflow-conscious code</span>
    <span class="keyword">int</span> oldCapacity = elementData.length;
    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);
    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)
        newCapacity = minCapacity;
    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)
        newCapacity = hugeCapacity(minCapacity);
    <span class="comment">// minCapacity is usually close to size, so this is a win:</span>
    elementData = Arrays.copyOf(elementData, newCapacity);
}
</code></pre><p>其实add方法没啥好讲的，就是先检查数组长度够不够再装一个，不够的话会调用grow方法“自动变长”，够的话就直接在size位置插入数据，然后把size加1。不过这里有个modCount++，这个modCount其实是在父类AbstractList中定义了一个int型的属性。</p>
<pre><code><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;
</code></pre><p>在ArrayList的所有涉及结构变化的方法中都增加modCount的值，包括：add()、remove()、addAll()、removeRange()、clear()方法。这些方法每调用一次，modCount的值就加1。</p>
<p>那么，modCount的作用是什么呢？这里可以把它理解为这个<strong>List的版本号</strong>。    </p>
<p>但是，<strong>List要版本号干嘛呢</strong>？</p>
<p>在对一个集合对象进行迭代操作的同时，并不限制对集合对象的元素进行操作，这些操作包括一些可能引起跌代错误的add()或remove()等危险操作。在AbstractList中，使用了一个简单的机制来规避这些风险。这就是modCount和expectedModCount的作用所在。下面是一个例子</p>
<pre><code>private class Itr implements Iterator&lt;E&gt; {
    int cursor;       // index of <span class="keyword">next</span> element to <span class="keyword">return</span>
    int lastRet = -<span class="number">1</span>; // index of last element returned; -<span class="number">1</span> <span class="keyword">if</span> no such
    int expectedModCount = modCount;
    <span class="keyword">...</span>
    <span class="keyword">...</span>
    final void checkForComodification() {
            <span class="keyword">if</span> (modCount != expectedModCount)
                throw new ConcurrentModificationException();
    }
    <span class="keyword">...</span>
    <span class="keyword">...</span>
}
</code></pre><p>比如在ArrayList的内部类Itr中的next()、remove()方法中都有调用checkForComodification()方法，目的就是为了防止在执行迭代时，List被修改了，造成数据不一致。除此之外，在writeObject()方法中也使用到了modCount，用法也是类似。</p>
<pre><code><span class="keyword">public</span> E remove(<span class="keyword">int</span> <span class="keyword">index</span>) {
    rangeCheck(<span class="keyword">index</span>);

    modCount++;
    E oldValue = elementData(<span class="keyword">index</span>);

    <span class="keyword">int</span> numMoved = size - <span class="keyword">index</span> - <span class="number">1</span>;
    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)
        System.arraycopy(elementData, <span class="keyword">index</span>+<span class="number">1</span>, elementData, <span class="keyword">index</span>,
                         numMoved);
    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span>

    <span class="keyword">return</span> oldValue;
}
</code></pre><p>可见，在remove()时，modCount执行了加1操作。</p>
<h3 id="2、clone，浅拷贝or深拷贝">2、clone，浅拷贝or深拷贝</h3>
<pre><code><span class="javadoc">/**
 * Returns a shallow copy of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance.  (The
 * elements themselves are not copied.)
 *
 *<span class="javadoctag"> @return</span> a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance
 */</span>
<span class="keyword">public</span> Object <span class="title">clone</span>() {
    <span class="keyword">try</span> {
        <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)
            ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) <span class="keyword">super</span>.clone();
        v.elementData = Arrays.copyOf(elementData, size);
        v.modCount = <span class="number">0</span>;
        <span class="keyword">return</span> v;
    } <span class="keyword">catch</span> (CloneNotSupportedException e) {
        <span class="comment">// this shouldn't happen, since we are Cloneable</span>
        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();
    }
}
</code></pre><p>拷贝之后，存储在原有List和克隆List中的对象会保持一致，并指向Java堆中同一内存地址，造成这一误解的原因是它采用Collections对不可变对象进行了浅拷贝。</p>
<h3 id="3、序列化">3、序列化</h3>
<p>在大型网站架构中，经常需要把对象进行序列化操作，以期在另外一台机器中恢复该对象并执行操作。常见的RPC（远程过程调用）经常就需要相应的序列化框架与其搭配使用。在ArrayList中，elementData数组对象定义为<a href="http://www.cnblogs.com/lanxuezaipiao/p/3369962.html" target="_blank" rel="external">transient</a>，也就是“瞬时的”，不能被序列化；这是因为elementData[]中存放的都是数据的引用，都是堆上的地址，所以如果对地址进行序列化其实是没有意义的，所以在这儿需要手工的对ArrayList的元素进行序列化操作。这就是writeObject()的作用。 </p>
<pre><code><span class="javadoc">/**
 * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that
 * is, serialize it).
 *
 *<span class="javadoctag"> @serialData</span> The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt;
 *             instance is emitted (int), followed by all of its elements
 *             (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order.
 */</span>
<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span>(java.io.ObjectOutputStream s)
    <span class="keyword">throws</span> java.io.IOException{
    <span class="comment">// Write out element count, and any hidden stuff</span>
    <span class="keyword">int</span> expectedModCount = modCount;
    s.defaultWriteObject();

    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span>
    s.writeInt(size);

    <span class="comment">// Write out all elements in the proper order.</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) {
        s.writeObject(elementData[i]);
    }

    <span class="keyword">if</span> (modCount != expectedModCount) {
        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();
    }
}

<span class="javadoc">/**
 * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is,
 * deserialize it).
 */</span>
<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span>(java.io.ObjectInputStream s)
    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException {
    elementData = EMPTY_ELEMENTDATA;

    <span class="comment">// Read in size, and any hidden stuff</span>
    s.defaultReadObject();

    <span class="comment">// Read in capacity</span>
    s.readInt(); <span class="comment">// ignored</span>

    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) {
        <span class="comment">// be like clone(), allocate array based upon size not capacity</span>
        ensureCapacityInternal(size);

        Object[] a = elementData;
        <span class="comment">// Read in all elements in the proper order.</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) {
            a[i] = s.readObject();
        }
    }
}
</code></pre><p>至此，ArrayList中关键点都已经介绍完毕。下面是Java Collection Framework框架图，点击可放大。<br><img src="http://blog.xumingyang.me/imgs/java-collection.jpg" alt="Collection FrameWork"></p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>ArrayList源码（JDK的源码在jdk安装目录下：src.zip）</li>
<li><a href="http://blog.csdn.net/justin_579/article/details/440003" target="_blank" rel="external">Java源码解读之java.util.ArrayList</a></li>
<li><a href="http://blog.xumingyang.cn/2015/03/19/RandomAccess%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">RandomAccess详解</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="概述">概述</h2>
<p>ArrayList是List、RandomAccess、Cloneable、Serializable接口的可变长数组实现。与Vector的最大区别就是没用使用Synchronized关键字进行同步。不过ArrayList对writeObject和readObject两个方法进行了同步。</p>
<pre><code><span class="comment">//java version "1.7.0_40"</span>
<span class="comment">//Java(TM) SE Runtime Environment (build 1.7.0_40-b43)</span>
<span class="comment">//Java HotSpot(TM) Client VM (build 24.0-b56, mixed mode, sharing)</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;
    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, 
    <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>{
    ...
}
</code></pre><p>其实ArrayList的各种特性就是AbstractList、RandomAccess、Cloneable、Serializable几种接口特性、当然还有它自己的特性的叠加(这几个都是maker interface，具体见这里)。<br>]]>
    
    </summary>
    
      <category term="java" scheme="http://blog.xumingyang.cn/tags/java/"/>
    
      <category term="容器" scheme="http://blog.xumingyang.cn/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="Java" scheme="http://blog.xumingyang.cn/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[源码浅析-Java中的并发数据集合]]></title>
    <link href="http://blog.xumingyang.cn/2015/03/12/java%20%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E9%9B%86%E5%90%88/"/>
    <id>http://blog.xumingyang.cn/2015/03/12/java 并发数据集合/</id>
    <published>2015-03-13T00:37:11.000Z</published>
    <updated>2015-03-30T01:29:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>并发集合是在并发环境下使用的一类集合，不同于普通的集合：ArrayList、HashSet等，并发集合在并发环境下不需要考虑数据不一致的情况，也就是说使用并发集合是<a href="http://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8" target="_blank" rel="external">线程安全</a>的。</p>
<p>一般来说，并发集合有如下两大类：</p>
<blockquote>
<ul>
<li>阻塞集合：这种集合包括添加和删除数据的操作。如果操作不能立即进行，是因为集合已满或者为空，该程序将被阻塞，直到操作可以进行。</li>
<li>非阻塞集合：这种集合也包括添加和删除数据的操作。如果操作不能立即进行，这个操作将返回null值或抛出异常，但该线程将不会阻塞。</li>
</ul>
</blockquote>
<a id="more"></a>

<p>具体的集合如下：</p>
<ul>
<li>非阻塞列表，使用ConcurrentLinkedDeque类。</li>
<li>非阻塞可导航的map，使用<a href="http://ifeve.com/concurrent-collections-6/" target="_blank" rel="external">ConcurrentSkipListMap</a>类。</li>
<li>阻塞列表，使用LinkedBlockingDeque类。</li>
<li>用在生产者与消费者数据的阻塞列表，使用LinkedTransferQueue类。</li>
<li>使用优先级排序元素的阻塞列表，使用<a href="http://ifeve.com/concurrent-collections-4/" target="_blank" rel="external">PriorityBlockingQueue</a>类。</li>
<li>存储延迟元素的阻塞列表，使用<a href="http://ifeve.com/concurrent-collections-5/" target="_blank" rel="external">DelayQueue</a>类。</li>
</ul>
<p><strong>下面详细从ConcurrentLinkedDeque和LinkedBlockingDeque源码入手分析。</strong></p>
<h2 id="ConcurrentLinkedDeque">ConcurrentLinkedDeque</h2>
<p>这是一个非阻塞集合，其主要成员对象如下</p>
<pre><code><span class="comment">//主要成员对象</span>
<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;
<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;
</code></pre><p>常用的方法有：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span>(E e)
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span>(E e)
<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span>(E e) //内部调用 <span class="title">addLast</span>(E e)

<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span>(E e) //调用<span class="title">addFirst</span>(E e)
<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span>(E e) //调用<span class="title">addLast</span>(E e)
<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span>(E e) //内部调用<span class="title">offerLast</span>(E e)

<span class="keyword">public</span> E <span class="title">pollFirst</span>() //弹出第一个，并返回
<span class="keyword">public</span> E <span class="title">pollLast</span>() //弹出最后一个 并返回

<span class="keyword">public</span> E <span class="title">removeFirst</span>() //调用<span class="title">pollFirst</span>()
<span class="keyword">public</span> E <span class="title">removeLast</span>() //调用<span class="title">pollLast</span>()

<span class="keyword">public</span> E <span class="title">poll</span>()           { <span class="keyword">return</span> pollFirst(); }
<span class="keyword">public</span> E <span class="title">remove</span>()         { <span class="keyword">return</span> removeFirst(); }
<span class="keyword">public</span> E <span class="title">peek</span>()           { <span class="keyword">return</span> peekFirst(); }
<span class="keyword">public</span> E <span class="title">element</span>()        { <span class="keyword">return</span> getFirst(); }
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span>(E e)     { addFirst(e); }
<span class="keyword">public</span> E <span class="title">pop</span>()            { <span class="keyword">return</span> removeFirst(); }
</code></pre><p>以offerFirst()代码为例，查看ConcurrentLinkedDeque内部方法的实现：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span>(E e) {
    linkFirst(e);
    <span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span>(E e) {
    checkNotNull(e);
    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);

    restartFromHead:
    <span class="keyword">for</span> (;;)
        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) {
            <span class="keyword">if</span> ((q = p.prev) != <span class="keyword">null</span> &amp;&amp;
                (q = (p = q).prev) != <span class="keyword">null</span>)
                <span class="comment">// Check for head updates every other hop.</span>
                <span class="comment">// If p == q, we are sure to follow head instead.</span>
                p = (h != (h = head)) ? h : q;
            <span class="keyword">else</span> <span class="keyword">if</span> (p.next == p) <span class="comment">// PREV_TERMINATOR</span>
                <span class="keyword">continue</span> restartFromHead;
            <span class="keyword">else</span> {
                <span class="comment">// p is first node</span>
                newNode.lazySetNext(p); <span class="comment">// CAS piggyback</span>
                <span class="keyword">if</span> (p.casPrev(<span class="keyword">null</span>, newNode)) {
                    <span class="comment">// Successful CAS is the linearization point</span>
                    <span class="comment">// for e to become an element of this deque,</span>
                    <span class="comment">// and for newNode to become "live".</span>
                    <span class="keyword">if</span> (p != h) <span class="comment">// hop two nodes at a time</span>
                        casHead(h, newNode);  <span class="comment">// Failure is OK.</span>
                    <span class="keyword">return</span>;
                }
                <span class="comment">// Lost CAS race to another thread; re-read prev</span>
            }
        }
}
</code></pre><p>ConcurrentLinkedDeque类中的head和tail是有volatile关键字修饰的，上面插入头结点的关键部分使用的是Node内部类中的方法，具体代码最后有附上。其方法并没有使用任何同步措施，比如：synchronizd关键字或ReentrantLock类，也正是因为这个，所以可以做到非阻塞，读者注意比较下面LinkedBlockingDeque。</p>
<h2 id="LinkedBlockingDeque">LinkedBlockingDeque</h2>
<p>这是一个阻塞集合，其主要成员如下</p>
<pre><code><span class="comment">//主要成员对象</span>
<span class="keyword">transient</span> Node&lt;E&gt; first;
<span class="keyword">transient</span> Node&lt;E&gt; last;
<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;

<span class="javadoc">/** Main lock guarding all access */</span>
<span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();

<span class="javadoc">/** Condition for waiting takes */</span>
<span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();

<span class="javadoc">/** Condition for waiting puts */</span>
<span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();
</code></pre><p>常用方法同上面的ConcurrentLinkedDeque类中提供的方法比较类似，addFirst/addLast/offerFirst/offerLast/pollFirst/pollLast等均有提供，不同的是，这些方法中都使用了lock进行同步，以offerFirst()方法为例</p>
<pre><code><span class="keyword">public</span> boolean <span class="title">offerFirst</span>(E e) {
    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();
    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);
    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;
    <span class="keyword">lock</span>.<span class="keyword">lock</span>();
    <span class="keyword">try</span> {
        <span class="keyword">return</span> linkFirst(node);
    } <span class="keyword">finally</span> {
        <span class="keyword">lock</span>.unlock();
    }
}

<span class="keyword">private</span> boolean <span class="title">linkFirst</span>(Node&lt;E&gt; node) {
    <span class="comment">// assert lock.isHeldByCurrentThread();</span>
    <span class="keyword">if</span> (count &gt;= capacity)
        <span class="keyword">return</span> <span class="keyword">false</span>;
    Node&lt;E&gt; f = first;
    node.next = f;
    first = node;
    <span class="keyword">if</span> (last == <span class="keyword">null</span>)
        last = node;
    <span class="keyword">else</span>
        f.prev = node;
    ++count;
    notEmpty.signal();
    <span class="keyword">return</span> <span class="keyword">true</span>;
}
</code></pre><p>在向当前deque中插入新数据时，会先使用lock()方法上锁，然后插入新节点作为第一个元素。</p>
<p><strong>ConcurrentLinkedDeque和LinkedBlockingDeque的区别</strong></p>
<ul>
<li>第一个区别：两者的方法一个使用Lock加锁，另一个则不是。</li>
<li>第二个区别：两者的内部Node类也有很大不同（具体看下面附上的Node类的代码）</li>
</ul>
<p>ConcurrentLinkedDeque类的Node类</p>
<pre><code><span class="keyword">static</span> <span class="keyword">final</span> class Node&lt;E&gt; {
    <span class="keyword">volatile</span> Node&lt;E&gt; prev;
    <span class="keyword">volatile</span> E item;
    <span class="keyword">volatile</span> Node&lt;E&gt; next;

    Node() {  <span class="comment">// default constructor for NEXT_TERMINATOR, PREV_TERMINATOR</span>
    }

    <span class="javadoc">/**
     * Constructs a new node.  Uses relaxed write because item can
     * only be seen after publication via casNext or casPrev.
     */</span>
    Node(E item) {
        UNSAFE.putObject(<span class="keyword">this</span>, itemOffset, item);
    }

    <span class="keyword">boolean</span> casItem(E cmp, E val) {
        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);
    }

    <span class="keyword">void</span> lazySetNext(Node&lt;E&gt; val) {
        UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, val);
    }

    <span class="keyword">boolean</span> casNext(Node&lt;E&gt; cmp, Node&lt;E&gt; val) {
        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);
    }

    <span class="keyword">void</span> lazySetPrev(Node&lt;E&gt; val) {
        UNSAFE.putOrderedObject(<span class="keyword">this</span>, prevOffset, val);
    }

    <span class="keyword">boolean</span> casPrev(Node&lt;E&gt; cmp, Node&lt;E&gt; val) {
        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, prevOffset, cmp, val);
    }

    <span class="comment">// Unsafe mechanics</span>

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> prevOffset;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> itemOffset;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;

    <span class="keyword">static</span> {
        <span class="keyword">try</span> {
            UNSAFE = sun.misc.Unsafe.getUnsafe();
            Class k = Node.class;
            prevOffset = UNSAFE.objectFieldOffset
                (k.getDeclaredField(<span class="string">"prev"</span>));
            itemOffset = UNSAFE.objectFieldOffset
                (k.getDeclaredField(<span class="string">"item"</span>));
            nextOffset = UNSAFE.objectFieldOffset
                (k.getDeclaredField(<span class="string">"next"</span>));
        } <span class="keyword">catch</span> (Exception e) {
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);
        }
    }
}
</code></pre><p>LinkedBlockingDeque类的Node类</p>
<pre><code>static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>{
    <span class="javadoc">/**
     * The item, or null if this node has been removed.
     */</span>
    E item;

    <span class="javadoc">/**
     * One of:
     * - the real predecessor Node
     * - this Node, meaning the predecessor is tail
     * - null, meaning there is no predecessor
     */</span>
    Node&lt;E&gt; prev;

    <span class="javadoc">/**
     * One of:
     * - the real successor Node
     * - this Node, meaning the successor is head
     * - null, meaning there is no successor
     */</span>
    Node&lt;E&gt; next;

    Node(E x) {
        item = x;
    }
}
</code></pre><p>有注意到LinkedBlockingDeque内部类的cas开头的几个函数吗?比如：casItem(),casNext()和casPrev(),这些都是CAS操作，CAS(Compare &amp; Set 或者 Compare &amp; Swap)为并发操作对象的提供更好的性能，CAS操作通过以下3个步骤来实现对变量值得修改：</p>
<ul>
<li>获取当前内存中的变量的值</li>
<li>用一个新的临时变量(temporal variable)保存改变后的新值</li>
<li>如果当前内存中的值等于变量的旧值，则将新值赋值到当前变量；否则不进行任何操作</li>
</ul>
<p>这里先介绍一下<code>乐观锁</code>和<code>悲观锁</code>：</p>
<blockquote>
<ul>
<li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。悲观锁假定其他用户企图访问或者改变你正在访问、更改的对象的概率是很高的，因此在悲观锁的环境中，在你开始改变此对象之前就将该对象锁住，并且直到你提交了所作的更改之后才释放锁。</li>
<li>乐观锁:假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。观锁不能解决脏读的问题。乐观锁则认为其他用户企图改变你正在更改的对象的概率是很小的，因此乐观锁直到你准备提交所作的更改时才将对象锁住，当你读取以及改变该对象时并不加锁。可见乐观锁加锁的时间要比悲观锁短，乐观锁可以用较大的锁粒度获得较好的并发访问性能。乐观锁中如果因为冲突失败就重试，直到成功为止。</li>
</ul>
</blockquote>
<p>对于这个机制，你不需要使用任何同步机制，这样你就避免了deadlocks，也获得了更好的性能。这种机制能保证多个并发线程对一个共享变量操作做到最终一致。Java 在原子类中实现了CAS机制。这些类提供了compareAndSet() 方法；这个方法是CAS操作的实现和其他方法的基础。</p>
<p>显然，阻塞队列使用悲观锁，基于Lock实现；非阻塞使用乐观锁，基于volatile和CAS实现。</p>
<h2 id="总结">总结</h2>
<ul>
<li>阻塞集合：如果操作不能立即进行，是因为集合已满或者为空，该程序将被阻塞，直到操作可以进行。</li>
<li>非阻塞集合：如果操作不能立即进行，这个操作将返回null值或抛出异常，但该线程将不会阻塞。</li>
</ul>
<p>问题1：CAS机制和传统的使用锁或者关键字相比，各自的优缺点，各自的适用情景(扩展阅读中有答案)？</p>
<p>这里先说一下<a href="http://www.cnblogs.com/pingh/p/3505486.html" target="_blank" rel="external">CAS的优缺点</a>：</p>
<blockquote>
<ul>
<li><p>优点：<br>非阻塞算法（通常叫作乐观算法）相对于基于锁的版本有几个性能优势。首先，它用硬件的原生形态代替 JVM 的锁定代码路径，从而在更细的粒度层次上（独立的内存位置）进行同步，失败的线程也可以立即重试，而不会被挂起后重新调度。更细的粒度降低了争用的机会，不用重新调度就能重试的能力也降低了争用的成本。即使有少量失败的 CAS 操作，这种方法仍然会比由于锁争用造成的重新调度快得多。</p>
</li>
<li><p>缺点：</p>
<ul>
<li>1、ABA问题<br>CAS操作容易导致ABA问题,也就是在做a++之间，a可能被多个线程修改过了，只不过回到了最初的值，这时CAS会认为a的值没有变。a在外面逛了一圈回来，你能保证它没有做任何坏事，不能！！也许它讨闲，把b的值减了一下，把c的值加了一下等等，更有甚者如果a是一个对象，这个对象有可能是新创建出来的，a是一个引用呢情况又如何，所以这里面还是存在着很多问题的，解决ABA问题的方法有很多，可以考虑增加一个修改计数，只有修改计数不变的且a值不变的情况下才做a++，也可以考虑引入版本号，当版本号相同时才做a++操作等，这和事务原子性处理有点类似！</li>
<li>2、比较花费CPU资源，即使没有任何争用也会做一些无用功。</li>
<li>3、会增加程序测试的复杂度，稍不注意就会出现问题。</li>
</ul>
</li>
</ul>
<p>可以用CAS在无锁的情况下实现原子操作，但要明确应用场合，非常简单的操作且又不想引入锁可以考虑使用CAS操作(比如get/set)，当想要非阻塞地完成某一操作也可以考虑CAS。不推荐在复杂操作中引入CAS，会使程序可读性变差，且难以测试，同时会出现ABA问题。嘿嘿嘿，CAS操作适用于那种读多写少的情况，因为这时CAS在更新时候冲突的概率会大大降低。</p>
</blockquote>
<h2 id="补充知识点">补充知识点</h2>
<ol>
<li>java中CAS的实现被封装在<a href="http://www.docjar.com/html/api/sun/misc/Unsafe.java.html" target="_blank" rel="external">sun.misc.Unsafe</a>类中。</li>
<li>java.util.concurrent.atomic中的AtomicInteger、AtomicIntegerArray、AtomicLong等都是基于CAS实现的。</li>
<li>volilate和cas只能乐观锁保证的状态控制的正确，而在设置状态失败的时候，仍然需要阻塞线程。juc里提供了LockSupport的park和unpark方法用于阻塞线程。而不同的场景下需要不同的等待策略和锁共享策略，juc提供了AbstractQueuedSynchronizer（AQS）为基类的一序列不同的锁，底层都是基于CAS、LocakSupport和Queue来管理。</li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://ifeve.com/concurrent-collections-1/" target="_blank" rel="external">并发集合</a></li>
<li><a href="http://ifeve.com/concurrent-collections-9/" target="_blank" rel="external">使用原子 arrays</a></li>
<li><a href="http://www.cnblogs.com/Bob-FD/p/3352216.html" target="_blank" rel="external">乐观锁和悲观锁的区别</a></li>
<li><a href="http://www.cnblogs.com/pingh/p/3505486.html" target="_blank" rel="external">乐观锁与悲观锁及其实现</a></li>
<li>Java源码（JDK的源码在jdk安装目录下：src.zip）</li>
</ul>
<h2 id="本文扩展阅读">本文扩展阅读</h2>
<ul>
<li><a href="http://www.infoq.com/cn/articles/atomic-operation" target="_blank" rel="external">原子操作的实现原理</a></li>
<li><a href="http://www.cnblogs.com/Mainz/p/3546347.html" target="_blank" rel="external">非阻塞同步算法与CAS算法</a></li>
<li><a href="http://coolshell.cn/articles/8239.html" target="_blank" rel="external">无锁队列的实现</a></li>
<li><a href="http://ifeve.com/reentrantlock-and-fairness/" target="_blank" rel="external">ReentrantLock(重入锁)以及公平性</a></li>
</ul>
<h2 id="Java并发资料">Java并发资料</h2>
<ul>
<li><a href="http://ifeve.com/java-concurrency-thread-directory/" target="_blank" rel="external">Java并发性和多线程</a></li>
<li><a href="http://ifeve.com/java-7-concurrency-cookbook/" target="_blank" rel="external">Java 7 并发编程指南</a></li>
<li><a href="http://ifeve.com/concurrency-modle-seven-week-1/" target="_blank" rel="external">七周七并发模型</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="概述">概述</h2>
<p>并发集合是在并发环境下使用的一类集合，不同于普通的集合：ArrayList、HashSet等，并发集合在并发环境下不需要考虑数据不一致的情况，也就是说使用并发集合是<a href="http://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8" target="_blank" rel="external">线程安全</a>的。</p>
<p>一般来说，并发集合有如下两大类：</p>
<blockquote>
<ul>
<li>阻塞集合：这种集合包括添加和删除数据的操作。如果操作不能立即进行，是因为集合已满或者为空，该程序将被阻塞，直到操作可以进行。</li>
<li>非阻塞集合：这种集合也包括添加和删除数据的操作。如果操作不能立即进行，这个操作将返回null值或抛出异常，但该线程将不会阻塞。</li>
</ul>
</blockquote>
]]>
    
    </summary>
    
      <category term="java" scheme="http://blog.xumingyang.cn/tags/java/"/>
    
      <category term="LinkedBlockingDeque" scheme="http://blog.xumingyang.cn/tags/LinkedBlockingDeque/"/>
    
      <category term="ConcurrentLinkedDeque" scheme="http://blog.xumingyang.cn/tags/ConcurrentLinkedDeque/"/>
    
      <category term="并发" scheme="http://blog.xumingyang.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="CAS" scheme="http://blog.xumingyang.cn/tags/CAS/"/>
    
      <category term="Java" scheme="http://blog.xumingyang.cn/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 中的重要知识点]]></title>
    <link href="http://blog.xumingyang.cn/2015/02/26/Java%20%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/"/>
    <id>http://blog.xumingyang.cn/2015/02/26/Java 资料汇总/</id>
    <published>2015-02-26T15:28:31.000Z</published>
    <updated>2015-04-07T14:40:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Java的容器">Java的容器</h2>
<p>顺序表、集合、队列相关类图<br><img src="http://xumyselfcn.github.io/imgs/Java_collection_implementation1.jpg" alt=""><br>Map相关类图<br><img src="http://xumyselfcn.github.io/imgs/Java_map_implementation1.jpg" alt=""><br>（图片来源：<a href="http://bighai.com/ppjava/?p=158" target="_blank" rel="external">Prepare Java Interview</a>）<br>上面第二幅图有错，LinkHashMap=&gt;LinkedHashMap</p>
<h3 id="非并发容器">非并发容器</h3>
<ul>
<li><a href="http://blog.xumingyang.cn/2015/03/27/ArrayList%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">ArrayList</a>和<a href="http://blog.xumingyang.cn/2015/03/27/LinkedList%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">LinkedList</a>（各自特点、区别、联系）</li>
<li><a href="http://www.importnew.com/10620.html" target="_blank" rel="external">Map（Hash冲突的解决）</a></li>
<li>Set</li>
<li>Stack、Queue</li>
</ul>
<p><a href="http://www.cnblogs.com/skywang12345/p/3323085.html#3157660" target="_blank" rel="external">这位</a>总结的很不错，推荐给大家。</p>
<h3 id="并发容器">并发容器</h3>
<ul>
<li>阻塞类的代表<a href="http://blog.xumingyang.cn/2015/03/12/java%20%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E9%9B%86%E5%90%88/#ConcurrentLinkedDeque" target="_blank" rel="external">LinkedBlockingDeque</a>、Vector</li>
<li>非阻塞类的代表<a href="http://blog.xumingyang.cn/2015/03/12/java%20%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E9%9B%86%E5%90%88/#LinkedBlockingDeque" target="_blank" rel="external">ConcurrentLinkedDeque</a><a id="more"></a></li>
<li>高效的<a href="http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/index.html?ca=drs-" target="_blank" rel="external">ConcurrentHashMap</a></li>
</ul>
<h2 id="JVM相关">JVM相关</h2>
<p><a href="http://en.wikipedia.org/wiki/Java_virtual_machine" target="_blank" rel="external">JVM</a>，也就是Java 虚拟机，由各大厂商根据<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/" target="_blank" rel="external">JVM规范</a>实现的。最有名的是甲骨文公司的HotSpot。JVM主要由：<strong>类加载子系统、运行时数据区（内存空间）、执行引擎和本地方法接口</strong>等组成。其中运行时数据区又由：<strong>方法区、堆、Java栈、PC寄存器、本地方法栈</strong>组成。</p>
<p><img src="http://xumyselfcn.github.io/imgs/jvm2.jpg" alt="JVM主要组成部分"></p>
<p>这个系列是<a href="http://github.thinkingbar.com/" target="_blank" rel="external">飘过的小牛</a>关于周志明的<a href="https://book.douban.com/subject/24722612/" target="_blank" rel="external">《深入理解Java虚拟机》</a>的读书笔记，我自己也看了一遍这本书（我看的是第一版的，现在已经有第二版了），再看看别人是怎么想的，每个人的关注点可能也不一样，有可能他注意到了我忽略的地方，顺带着复习一下，这是一种很好的学习方式。</p>
<ul>
<li><a href="http://github.thinkingbar.com/jvm-ii/" target="_blank" rel="external">Java内存区域与内存溢出异常</a></li>
<li><a href="http://github.thinkingbar.com/jvm-iv/" target="_blank" rel="external">JVM性能监控与故障处理工具</a></li>
<li><a href="http://github.thinkingbar.com/jvm-vi/" target="_blank" rel="external">类文件结构</a></li>
<li><a href="http://github.thinkingbar.com/jvm-vii/" target="_blank" rel="external">虚拟机类加载机制</a></li>
<li><a href="http://www.importnew.com/15362.html" target="_blank" rel="external">深入分析Java ClassLoader原理</a></li>
<li><a href="http://github.thinkingbar.com/jvm-viii/" target="_blank" rel="external">虚拟机字节码执行引擎</a></li>
<li><a href="http://github.thinkingbar.com/jvm-ix/" target="_blank" rel="external">类加载及执行子系统的案例与实战</a></li>
<li><a href="http://github.thinkingbar.com/jvm-xii/" target="_blank" rel="external">Java内存模型与线程</a></li>
</ul>
<h2 id="Java_I/O">Java I/O</h2>
<p>待补充</p>
<ul>
<li><a href="http://fangguanhong.iteye.com/blog/1976393" target="_blank" rel="external">Java IO “装饰模式(Decorator)”总结</a></li>
</ul>
<h2 id="Java多线程">Java多线程</h2>
<p>以前用到多线程的时候，在网上搜一下资料，实现功能就行；后来看了<a href="http://book.douban.com/subject/25844475/" target="_blank" rel="external">《Java 7并发编程实战手册》</a>算是真正的入门，这本书的特点是例子很多，跟着例子走上手比较容易，缺点就是例子太多，容易只见树木不见森林，局限于某个知识点。</p>
<p>这里是<a href="http://ifeve.com/java-7-concurrency-cookbook/" target="_blank" rel="external">《Java 7 Concurrency Cookbook》</a>的中文翻译在线版，已经出版的《Java 7并发编程实战手册》是其中文译本。</p>
<p>其他的Java并发编程资料：</p>
<ul>
<li>排名第一的自然是<a href="http://book.douban.com/subject/10484692/" target="_blank" rel="external">《Java并发编程实战》</a></li>
<li><a href="http://ifeve.com/java-concurrency-thread-directory/" target="_blank" rel="external">Java并发性和多线程</a></li>
</ul>
<p>怎么才能构建一个Java并发编程的体系呢，下面的这个系统对Java多线程整体过了一遍，这个系列依旧是<a href="http://github.thinkingbar.com/" target="_blank" rel="external">飘过的小牛</a>的读书笔记。</p>
<ul>
<li><a href="http://github.thinkingbar.com/thinking_in_java_chapter21-part01/" target="_blank" rel="external">Java编程思想-并发系列之一</a></li>
<li><a href="http://github.thinkingbar.com/thinking_in_java_chapter21-part02/" target="_blank" rel="external">Java编程思想-并发系列之二</a></li>
<li><a href="http://github.thinkingbar.com/thinking_in_java_chapter21-part03/" target="_blank" rel="external">Java编程思想-并发系列之三</a></li>
<li><a href="http://github.thinkingbar.com/thinking_in_java_chapter21-part04/" target="_blank" rel="external">Java编程思想-并发系列之四</a></li>
<li><a href="http://github.thinkingbar.com/thinking_in_java_chapter21-part05/" target="_blank" rel="external">Java编程思想-并发系列之五</a></li>
<li><a href="http://github.thinkingbar.com/thinking_in_java_chapter21-part06/" target="_blank" rel="external">Java编程思想-并发系列之六</a></li>
</ul>
<h2 id="Java其他关键知识点">Java其他关键知识点</h2>
<ul>
<li><a href="http://www.importnew.com/15397.html" target="_blank" rel="external">深入理解Java String#intern() 内存模型</a></li>
</ul>
<h3 id="Java序列化">Java序列化</h3>
<p>下面就是序列化相关的知识点：</p>
<ul>
<li>为什么要序列化、序列化的应用场景？</li>
<li>序列化的实现方法？</li>
<li>已有的序列化框架？</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Java的容器">Java的容器</h2>
<p>顺序表、集合、队列相关类图<br><img src="http://xumyselfcn.github.io/imgs/Java_collection_implementation1.jpg" alt=""><br>Map相关类图<br><img src="http://xumyselfcn.github.io/imgs/Java_map_implementation1.jpg" alt=""><br>（图片来源：<a href="http://bighai.com/ppjava/?p=158" target="_blank" rel="external">Prepare Java Interview</a>）<br>上面第二幅图有错，LinkHashMap=&gt;LinkedHashMap</p>
<h3 id="非并发容器">非并发容器</h3>
<ul>
<li><a href="http://blog.xumingyang.cn/2015/03/27/ArrayList%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">ArrayList</a>和<a href="http://blog.xumingyang.cn/2015/03/27/LinkedList%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">LinkedList</a>（各自特点、区别、联系）</li>
<li><a href="http://www.importnew.com/10620.html" target="_blank" rel="external">Map（Hash冲突的解决）</a></li>
<li>Set</li>
<li>Stack、Queue</li>
</ul>
<p><a href="http://www.cnblogs.com/skywang12345/p/3323085.html#3157660" target="_blank" rel="external">这位</a>总结的很不错，推荐给大家。</p>
<h3 id="并发容器">并发容器</h3>
<ul>
<li>阻塞类的代表<a href="http://blog.xumingyang.cn/2015/03/12/java%20%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E9%9B%86%E5%90%88/#ConcurrentLinkedDeque" target="_blank" rel="external">LinkedBlockingDeque</a>、Vector</li>
<li>非阻塞类的代表<a href="http://blog.xumingyang.cn/2015/03/12/java%20%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E9%9B%86%E5%90%88/#LinkedBlockingDeque" target="_blank" rel="external">ConcurrentLinkedDeque</a>]]>
    
    </summary>
    
      <category term="java" scheme="http://blog.xumingyang.cn/tags/java/"/>
    
      <category term="Java" scheme="http://blog.xumingyang.cn/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从Oracle数据库中大量导出文本数据的实践]]></title>
    <link href="http://blog.xumingyang.cn/2014/12/08/%E4%BB%8EOracle%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%A4%A7%E9%87%8F%E5%AF%BC%E5%87%BA%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
    <id>http://blog.xumingyang.cn/2014/12/08/从Oracle数据库中大量导出文本数据的实践/</id>
    <published>2014-12-08T20:32:25.000Z</published>
    <updated>2015-04-09T12:01:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>在网页上选择待导出的数据表和字段，从Oracle数据库中导出，以文本方式保存。比较大的一张表估计得有几千万行了。目标导出速度得达到15w行/s左右。</p>
<h2 id="使用JDBC">使用JDBC</h2>
<p>通过JDBC连接数据库的方式导出数据，最开始的想法是这样：</p>
<ol>
<li>读取该表的记录数M</li>
<li>设置每次读取的记录数N，计算出读取的次数X=M/N+1</li>
<li>循环X次，每次从数据库中读取N（用的是项目中现有的分页接口）</li>
<li>把结果写到文件中</li>
</ol>
<p>大概下图的样子：</p>
<p><img src="http://img-niren.qiniudn.com/1-1.png" alt=""></p>
<p>测试了下，结果很不好。</p>
<p>于是有了下面的想法：</p>
<ol>
<li>在上面的基础上开三个子线程，连接数据库，读取数据</li>
<li>将每次读取的数据存放在一个队列中</li>
<li>再开一个写文件的子线程，检查队列是否为空，否则把队列中的数据写入到文件中</li>
</ol>
<p>大概是下图的这个样子。</p>
<p><img src="http://img-niren.qiniudn.com/1-2.png" alt=""></p>
<p>测试了下，结果依旧不理想。仔细分析了下各个过程的耗时，发现瓶颈均是在从数据库读取数据这个地方。最开始读取一次大概1s的样子，到最后甚至得需要10s中才能返回一条记录，而且多线程并不能起到加快读取数据的目的。</p>
<p>好吧，瓶颈在数据库读取部分。其实也就表明，这种方法不行啊~</p>
<h2 id="使用exp/expdp">使用exp/expdp</h2>
<p>这里使用的是oracle提供的expdp工具，使用这个工具的大概步骤如下：</p>
<pre><code>//这是在SQL*PLUS中进行操作
//创建逻辑目录
<span class="operator"><span class="keyword">create</span> directory dpdata3 <span class="keyword">as</span> <span class="string">'/home/oracle/expdp'</span>;</span>
//查看管理员目录下面是否创建成功
<span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> dba_directories;</span>
//给普通的数据库用户赋予在指定目录的操作权限
<span class="operator"><span class="keyword">grant</span> <span class="keyword">read</span>,<span class="keyword">write</span> <span class="keyword">on</span> directory dpdata3 <span class="keyword">to</span> <span class="keyword">User</span>;</span>
</code></pre><p>在shell命令行中执行：</p>
<pre><code>expdp User/Pwd <span class="variable">TABLES=</span>tableName <span class="variable">dumpfile=</span>expdp.dmp <span class="variable">DIRECTORY=</span>dpdata3;
</code></pre><p>这样在<code>/home/oracle/expdp</code>目录中就生成了expdp.dmp文件，这个文件就是从oracle数据库中导出的二进制数据文件。</p>
<p>但是这个方案有个问题，导出的二进制数据如何转换成文本数据？</p>
<p>找了一下，没有理想的方案。</p>
<p>关于expdp命令的详细信息可以参考<a href="http://shitou118.blog.51cto.com/715507/310033" target="_blank" rel="external">expdp impdp 数据库导入导出命令详解</a></p>
<h2 id="使用spool">使用spool</h2>
<p>使用spool。这里是从某个表中导出数据的spool脚本：</p>
<pre><code><span class="operator"><span class="keyword">set</span> echo <span class="keyword">on</span>;</span>
<span class="operator"><span class="keyword">set</span> feedback <span class="keyword">on</span>;</span>
<span class="operator"><span class="keyword">set</span> trimspool off;</span>
<span class="operator"><span class="keyword">set</span> linesize <span class="number">120</span>;</span>
<span class="operator"><span class="keyword">set</span> pagesize <span class="number">2000</span>;</span>
<span class="operator"><span class="keyword">set</span> newpage <span class="number">1</span>;</span>
<span class="operator"><span class="keyword">set</span> heading <span class="keyword">on</span>;</span>
<span class="operator"><span class="keyword">set</span> term off;</span>
<span class="operator"><span class="keyword">set</span> termout <span class="keyword">on</span>;</span>
<span class="operator"><span class="keyword">set</span> timing off;</span>
spool /home/oracle/xmy/oracle/spool/data.txt;
<span class="operator"><span class="keyword">select</span> <span class="string">'"'</span>||id||<span class="string">'"'</span>||<span class="string">','</span>||lasttime||<span class="string">','</span>||taskname||<span class="string">','</span>||algtype||<span class="string">','</span>||to_number(to_char(starttime,<span class="string">'YYYYMMDD'</span>)) <span class="keyword">from</span> common;</span>
spool off;
</code></pre><p>这里就是从common表中导出id、lasttime等字段。具体的执行方法是登陆sqlplus，然后执行</p>
<pre><code><span class="comment">#登陆</span>
sqlplus / <span class="keyword">as</span> sysdba
<span class="comment">#@后面跟的是脚本的路径</span>
<span class="decorator">@spool.sh</span>
</code></pre><p>这种方法效率也是比较低。</p>
<h2 id="使用Pro*C">使用Pro*C</h2>
<p>仿照网上的Pro*C程序一直编译出错，据说这个的效率非常高。</p>
<h2 id="使用sqluldr2工具">使用sqluldr2工具</h2>
<p>这个方案也是最后采用的。</p>
<p>sqluldr2工具是由<a href="http://weibo.com/dbatools" target="_blank" rel="external">平民架构</a>开发的，有免费版和商业版之分，不过我这里免费版就已经够用了。这个工具可以在<a href="http://www.anysql.net/download" target="_blank" rel="external">anysql</a>下载到（第5个，Oracle文本导出工具），里面有windows/linux的32/64位四个版本的执行文件。</p>
<p>我是把这个工具放在了/usr/local/bin中，因为这个路径已经在环境变量中设置了，所以现在可以全局使用这个命令。</p>
<p>直接使用命令：</p>
<pre><code>sqluldr2_linux64_10204.bin <span class="variable">user=</span>user/pwd <span class="variable">query=</span><span class="string">"select * from common"</span> <span class="variable">file=</span>data.csv <span class="variable">head=</span>no <span class="variable">charset=</span>UTF8
</code></pre><p>就可以导出common表中的数据了，在当前路径中生成文件data.csv。</p>
<p>这里有关于expdp和sqluldr2的性能测试截图：</p>
<p>这个是expdp工具的测试截图<br><img src="http://img-niren.qiniudn.com/expdp-modify.png" alt=""><br>这个是sqluldr2工具的测试截图<br><img src="http://img-niren.qiniudn.com/sqluldr2-modify.png" alt=""></p>
<p>两者导出的数据都是一样的，一共26405520行记录，大约1.4GG。两者耗时相差不大，都在两分钟以内，不过，可以发现sqluldr2甚至比oracle官方提供的expdp工具还要快一些。</p>
<p>在实际项目中遇到了一个问题：这个工具（不止这个工具，除了第一种方案，其他的都需要）必须得在有oracle环境下才能运行，项目部署的用户和数据库的用户并不是同一个。</p>
<p>一个方法就是在当前用户下，切换到另外一个用户去执行命令，但是这就需要输入数据库用户的用户名和密码，查资料可以通过安装expect工具，写成shell脚本，然后程序直接调用执行这个脚本。</p>
<p>另一个方法是在数据库用户下部署一个server，当需要导出数据的时候，给该server发送相应的信息（包括需要导出的表名，字段名）。server接受信息之后开始执行数据导出工作。</p>
<p>现在实现了第二种方法，其实这两个方法都挺麻烦的，不知道有没有更简便的方法。</p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="http://shitou118.blog.51cto.com/715507/310033" target="_blank" rel="external">expdp impdp 数据库导入导出命令详解</a></li>
<li><a href="http://blog.csdn.net/cmingjun/article/details/5343019" target="_blank" rel="external">SQLPLUS SPOOL命令使用详解</a></li>
<li><a href="http://stackoverflow.com/questions/11555847/how-to-pump-data-to-txt-file-using-oracle-datapump" target="_blank" rel="external">How to pump data to txt file using Oracle datapump?</a></li>
<li><a href="https://asktom.oracle.com/pls/apex/f?p=100:11:0::::P11_QUESTION_ID:459020243348" target="_blank" rel="external">关于Pro*C的一篇国外的文章</a></li>
<li><a href="http://blog.csdn.net/leexide/article/details/17485451" target="_blank" rel="external">Shell脚本学习之expect命令</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="背景">背景</h2>
<p>在网页上选择待导出的数据表和字段，从Oracle数据库中导出，以文本方式保存。比较大的一张表估计得有几千万行了。目标导出速度得达到15w行/s左右。</p>
<h2 id="使用JDBC">使用JDBC</h2>
<p>通过JDBC连]]>
    </summary>
    
      <category term="oracle" scheme="http://blog.xumingyang.cn/tags/oracle/"/>
    
      <category term="spool" scheme="http://blog.xumingyang.cn/tags/spool/"/>
    
      <category term="expdp" scheme="http://blog.xumingyang.cn/tags/expdp/"/>
    
      <category term="sqluldr2" scheme="http://blog.xumingyang.cn/tags/sqluldr2/"/>
    
      <category term="Oracle" scheme="http://blog.xumingyang.cn/categories/Oracle/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[docker 入门操作]]></title>
    <link href="http://blog.xumingyang.cn/2014/10/15/wiki/docker%E5%85%A5%E9%97%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://blog.xumingyang.cn/2014/10/15/wiki/docker入门操作/</id>
    <published>2014-10-16T00:38:00.000Z</published>
    <updated>2014-10-15T12:20:26.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.docker.com/" target="_blank" rel="external">Docker</a> is a platform for developers and sysadmins to <strong>develop, ship, and run applications</strong>. Docker lets you quickly assemble applications from components and eliminates the friction that can come when shipping code. Docker lets you get your code tested and deployed into production as fast as possible.</p>
</blockquote>
<p>检查docker是否安装成功：</p>
<pre><code>root@<span class="operator"><span class="keyword">do</span>:~# docker <span class="keyword">version</span>
//如下显示则表明docker安装成功。

Client <span class="keyword">version</span>: <span class="number">1.0</span><span class="number">.1</span>
Client API <span class="keyword">version</span>: <span class="number">1.12</span>
<span class="keyword">Go</span> <span class="keyword">version</span> (client): go1<span class="number">.2</span><span class="number">.1</span>
Git <span class="keyword">commit</span> (client): <span class="number">990021</span>a
<span class="keyword">Server</span> <span class="keyword">version</span>: <span class="number">1.0</span><span class="number">.1</span>
<span class="keyword">Server</span> API <span class="keyword">version</span>: <span class="number">1.12</span>
<span class="keyword">Go</span> <span class="keyword">version</span> (<span class="keyword">server</span>): go1<span class="number">.2</span><span class="number">.1</span>
Git <span class="keyword">commit</span> (<span class="keyword">server</span>): <span class="number">990021</span>a</span>
</code></pre><h3 id="使用Docker输出hello_world">使用Docker输出hello world</h3>
<pre><code>docker run ubuntu:<span class="number">14.04</span> /bin/<span class="built_in">echo</span> <span class="string">'Hello world'</span>
</code></pre><p><code>docker run</code>：运行容器</p>
<p><code>ubuntu:14.04</code>：指定image。</p>
<blockquote>
<p>This is the source of the container we ran. Docker calls this an image. </p>
</blockquote>
<p>这里我们运行的是ubuntu 14.04 操作系统 image。</p>
<p><code>/bin/echo &#39;Hello world&#39;</code>：当我们的容器启动之后，Docker创建了一个新的Ubuntu14.04环境，然后在这个ubuntu系统中执行<code>/bin/echo &#39;Hello world&#39;</code>。</p>
<h3 id="创建一个可交互的容器">创建一个可交互的容器</h3>
<pre><code>root<span class="variable">@do</span><span class="symbol">:~</span><span class="comment"># docker run -t -i ubuntu:14.04 /bin/bash</span>
root<span class="variable">@dc270626bc6e</span><span class="symbol">:/</span><span class="comment"># </span>
</code></pre><p>这里多了两个参数<code>t</code>和<code>i</code>。</p>
<blockquote>
<p>-t：assigns a pseudo-tty or terminal inside our new container</p>
<p>-i：allows us to make an interactive connection by grabbing the standard in (STDIN) of the container</p>
</blockquote>
<p>这个时候，我们可以在新创建的ubuntu终端里面进行bash操作。</p>
<pre><code>root@<span class="keyword">do</span>:~<span class="comment"># docker run -t -i ubuntu:14.04 /bin/bash</span>
root@dc270626bc6e:/<span class="comment"># pwd</span>
/
root@dc270626bc6e:/<span class="comment"># ls</span>
bin  boot  dev    etc  home  lib    lib64  media  mnt  opt    <span class="keyword">proc</span>  root  run  sbin  srv  sys  tmp  usr  <span class="keyword">var</span>
root@dc270626bc6e:/<span class="comment"># </span>
</code></pre><p>最后输入<code>exit</code>或者按Ctrl+d来关闭这个容器。</p>
<h3 id="创建一个在后台运行的容器">创建一个在后台运行的容器</h3>
<pre><code>root<span class="variable">@do</span><span class="symbol">:~</span><span class="comment"># docker run -d ubuntu:14.04 /bin/sh -c "while true; do echo hello world; sleep 1; done"</span>
0c981b692eb2f2b3aee085cb873231e9f77ddf9516352bbf080176d8c8567df7
</code></pre><blockquote>
<p>The -d flag tells Docker to run the container and put it in the background, to daemonize it.表示在后台运行该容器。</p>
</blockquote>
<p>提交刚才的命令之后，终端会打印<br>    0c981b692eb2f2b3aee085cb873231e9f77ddf9516352bbf080176d8c8567df7</p>
<p>这个是创建的容器的ID，用于唯一标志容器。</p>
<blockquote>
<p>The container ID is a bit long and unwieldy and a bit later on we’ll see a shorter ID and some ways to name our containers to make working with them easier.</p>
</blockquote>
<p>该容器中执行<code>/bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</code>。这个时候在前台看不见任何输出。</p>
<p>执行<code>docker ps</code>查看后台运行的容器。</p>
<pre><code>root@<span class="operator"><span class="keyword">do</span>:~# docker ps
CONTAINER ID        IMAGE               COMMAND                CREATED             <span class="keyword">STATUS</span>              PORTS               <span class="keyword">NAMES</span>
<span class="number">0</span>c981b692eb2        ubuntu:<span class="number">14.04</span>        /<span class="keyword">bin</span>/sh -c <span class="string">'while tr   4 seconds ago       Up 4 seconds                            backstabbing_brown</span></span>
</code></pre><p>最后一列Names是docker自动给容器分配的名称，自己也可以对其进行修改。</p>
<p>执行<code>docker logs [name]</code>查看后台容器的输出。</p>
<pre><code>root<span class="variable">@do</span><span class="symbol">:~</span><span class="comment"># docker logs backstabbing_brown</span>
hello world
hello world
hello world
```
</code></pre><p>执行<code>docker stop [name]</code>，关闭该后台容器。</p>
<pre><code>root<span class="variable">@do</span><span class="symbol">:~</span><span class="comment"># docker stop backstabbing_brown</span>
backstabbing_brown
</code></pre><h3 id="本篇命令总结">本篇命令总结</h3>
<pre><code>docker run ubuntu:<span class="number">14.04</span> <span class="regexp">/bin/</span>echo <span class="string">'Hello world'</span>

docker run -t -i ubuntu:<span class="number">14.04</span> <span class="regexp">/bin/</span>bash (-t带终端，-i可交互)

docker run -d ubuntu:<span class="number">14.04</span> <span class="regexp">/bin/</span>sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span>
(返回 container ID，用于唯一标示container。)

docker ps
查看docker的后台进程

docker logs [NAMES]
这里的[NAMES]是使用 docker ps 查看后台进程的时候，最后一列信息。
docker logs 会返回该容器的标准输出

docker stop [NAMES]
停止正在运行的容器
</code></pre><blockquote>
<p>参考自docker文档：<a href="https://docs.docker.com/userguide/dockerizing/" target="_blank" rel="external">https://docs.docker.com/userguide/dockerizing/</a></p>
<p><a href="https://docs.docker.com/reference/commandline/cli/" target="_blank" rel="external">这里</a>有更多的关于Docker的命令介绍。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p><a href="https://www.docker.com/" target="_blank" rel="external">Docker</a> is a platform for developers and sysadmins to <s]]>
    </summary>
    
      <category term="docker" scheme="http://blog.xumingyang.cn/tags/docker/"/>
    
      <category term="Docker" scheme="http://blog.xumingyang.cn/categories/Docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[docker 安装]]></title>
    <link href="http://blog.xumingyang.cn/2014/10/15/wiki/docker%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>http://blog.xumingyang.cn/2014/10/15/wiki/docker的安装/</id>
    <published>2014-10-15T20:20:00.000Z</published>
    <updated>2014-10-15T11:46:48.000Z</updated>
    <content type="html"><![CDATA[<p>Docker的安装详见<a href="https://docs.docker.com/installation/ubuntulinux/" target="_blank" rel="external">Docker的官方文档</a>。</p>
<p>官方文档包含Ubuntu、Mac OS、Red Hat Enterprise Linux、CentOS等系统安装Docker的方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Docker的安装详见<a href="https://docs.docker.com/installation/ubuntulinux/" target="_blank" rel="external">Docker的官方文档</a>。</p>
<p>官方文档包含Ubunt]]>
    </summary>
    
      <category term="Docker" scheme="http://blog.xumingyang.cn/tags/Docker/"/>
    
      <category term="Docker" scheme="http://blog.xumingyang.cn/categories/Docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM垃圾收集]]></title>
    <link href="http://blog.xumingyang.cn/2014/05/20/wiki/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"/>
    <id>http://blog.xumingyang.cn/2014/05/20/wiki/Java垃圾收集/</id>
    <published>2014-05-20T14:17:16.000Z</published>
    <updated>2015-04-08T06:13:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="内存回收的三个问题">内存回收的三个问题</h2>
<ul>
<li>What</li>
<li>When</li>
<li>How</li>
</ul>
<h3 id="WHAT">WHAT</h3>
<p>程序计数器、虚拟机栈、本地方法栈三个区域都是线程私有的，也就是生命周期与线程一样。这几个区域的内存分配和回收不需考虑太多，因为随着方法的结束，内存自然就回收了。</p>
<p>所以内存回收关注的重点就是：<code>Java堆</code>和<code>方法区</code>。</p>
<h3 id="WHEN">WHEN</h3>
<h4 id="栈">栈</h4>
<p>当方法执行完毕，该栈帧就自行销毁。</p>
<h4 id="堆">堆</h4>
<p>Java堆应该什么时候回收呢，或者是当堆中的对象达到什么条件就应该被回收呢？</p>
<ul>
<li>当对象的引用数为0时回收</li>
</ul>
<p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器值加一；当引用失效时，计数器值就减一；任何时刻，计数器为0的对象就是不可能再被使用的。也就是应该被回收的对象。</p>
<p>先声明一下，Java不是这么做的。<br>微软的COM、FlashPlayer、Python、Squirrel是采用的这种方法。<br>缺点：很难解决对象间的循环引用问题。</p>
<ul>
<li>对象不可到达时被回收<br>主流的商用程序语言（Java、C#、甚至是Lisp）都是采用的根搜索算法（GC Roots Tracing）判断对象是否存活。</li>
</ul>
<p>根搜索算法的基本思路是：有一系列的称之为 <strong>GC Roots</strong> 的对象，从这些对象出发，向下搜索，搜索走过的路径称为<strong>引用链</strong>（Reference Chain），当一个对象到GC Roots不可达时（即不存在能将该对象链接到GC Roots的引用链），这个对象就是应该被回收。</p>
<blockquote>
<p>什么对象才能加入GC Roots阵营呢？</p>
<ul>
<li>虚拟机栈（其实是栈帧中的本地变量表）中的引用的对象。</li>
<li>第二种：方法区中类静态属性引用的对象。</li>
<li>第三种：方法区中的常量引用的对象。</li>
<li>第四种：本地方法栈中的JNI（也就是Native方法）的引用的对象。（对照虚拟机栈用本地方法栈的诸多相似点，本条同第一条其实也是类似的，虚拟机栈同本地方法栈真是一对好基友。）</li>
</ul>
</blockquote>
<p>在根搜索算法中，真正宣告一个对象死亡，至少要经历两次标记过程。</p>
<h4 id="方法区">方法区</h4>
<p>在方法区进行垃圾收集的性价比一般比较低。主要回收：废弃常量和无用的类。</p>
<ul>
<li><p>回收废弃常量。<br>&gt;</p>
<blockquote>
<p>回收废弃常量类似回收Java堆中的对象，以常量池中的字符串回收为例：加入一个字符串“abc”已经进入常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，如果这个时候发生内存回收，而且必要的话，这个“abc”就会被回收。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p>
</blockquote>
</li>
<li><p>回收无用的类</p>
</li>
</ul>
<blockquote>
<p>当一个类满足以下的三个条件才算是“无用的类”</p>
<ul>
<li>该类所有的实例都已经回收，Java堆中不存在任何该类的实例</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
</blockquote>
<p>虚拟机可以对满足上述三个条件的无用类进行回收，用<em>可以</em>是因为并不是不用了就会对其回收。虚拟机会在需要的时候进行回收。</p>
<blockquote>
<p>在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，保证方法区不会溢出。 </p>
</blockquote>
<h3 id="HOW">HOW</h3>
<h4 id="垃圾回收算法">垃圾回收算法</h4>
<h5 id="标记-清除算法">标记-清除算法</h5>
<p>Mark-Sweep：先标记所有需要回收对象，然后统一回收。</p>
<p>问题</p>
<ul>
<li>效率问题，标记和清除两个过程的效率都不高。</li>
<li>空间问题，会产生大量不连续的内存碎片。分配大对象时容易提前触发GC。</li>
</ul>
<h5 id="复制算法">复制算法</h5>
<p>Copying：把可用内存分为大小相等的两块，每次只使用一块。当一块用完时，将存活对象复制到另一块，再一次清理掉已使用的内存块。</p>
<p>实现简单，分配快，只需要顺序移动堆顶指针就可以进行分配，允许高效。代价是内存浪费大。</p>
<p>IBM的研究表明，新产生的对象98%都是很快就死忙的。</p>
<p>HotSpot将内存分为一块较大的Eden和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。回收时，将Eden和Survivor中存活的对象一次性复制到另一个Survivor上，然后清理掉Eden和用过的Survivor。</p>
<p>在上面的复制过程中，如果Survivor空间不够，则需要引入一种分配担保机制来处理，在HotSpot中是将对象分配到年老代。</p>
<h5 id="标记-压缩">标记-压缩</h5>
<p>Mark-Compact：先标记，然后将存活对象移向一边，再清理掉边界以外的内存。</p>
<h5 id="分代收集算法">分代收集算法</h5>
<ul>
<li><p>一般的虚拟机都是分代收集算法，也就是把内存分为几个块，不同的块用不同的回收算法。</p>
</li>
<li><p>一般将内存分为新生代和年老代，在新生代一般采用复制算法，年老代采用标记-压缩算法。</p>
</li>
</ul>
<h2 id="几种垃圾收集器">几种垃圾收集器</h2>
<ul>
<li>Serial串行GC收集器</li>
<li>ParNew并行GC收集器</li>
<li>Parallel Scavenge并行回收GC收集器</li>
<li>Serial Old串行GC收集器</li>
<li>Parallel Old并行GC收集器</li>
<li>CMS并发GC收集器</li>
<li>G1收集器</li>
</ul>
<p>这里推荐大家看周志明的《深入理解Java虚拟机》的第3.4节。<a href="http://blog.csdn.net/java2000_wl/article/details/8030172" target="_blank" rel="external">这篇博文</a>大概描述了各个垃圾收集器，包括他们使用了何种算法，是单线程、还是支持并行、并发的。<a href="http://www.importnew.com/15311.html" target="_blank" rel="external">这篇文章</a>较详细的介绍了G1垃圾收集器。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>周志明 《深入理解Java虚拟机》</li>
<li><a href="http://blog.csdn.net/java2000_wl/article/details/8030172" target="_blank" rel="external">Java虚拟机学习 - 垃圾收集器</a></li>
<li><a href="http://www.importnew.com/15311.html" target="_blank" rel="external">JVM中的G1垃圾回收器</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="内存回收的三个问题">内存回收的三个问题</h2>
<ul>
<li>What</li>
<li>When</li>
<li>How</li>
</ul>
<h3 id="WHAT">WHAT</h3>
<p>程序计数器、虚拟机栈、本地方法栈三个区域都是线程私有的]]>
    </summary>
    
      <category term="Java" scheme="http://blog.xumingyang.cn/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java内存区域]]></title>
    <link href="http://blog.xumingyang.cn/2014/05/16/wiki/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://blog.xumingyang.cn/2014/05/16/wiki/Java内存区域/</id>
    <published>2014-05-16T14:17:16.000Z</published>
    <updated>2015-04-08T06:13:22.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一种JVM运行时数据区划分">一种JVM运行时数据区划分</h2>
<p><img src="http://xumyselfcn.github.io/imgs/JVM-runtime-data-area.jpg" alt=""></p>
<p>（图片来源：<a href="http://www.programcreek.com/2013/04/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/" target="_blank" rel="external">JVM运行时是什么样子</a>）<br>从上图可以看出，JVM的数据区可以分成两部分</p>
<h4 id="每个线程的数据区">每个线程的数据区</h4>
<p>每个线程有program counter register(程序计数器)，JVM Stack(JVM栈),和Native Method Stack(本地方法栈)。　这三个区域都是基于每一个线程的，当一个线程创建的时候生成。</p>
<p>程序计数器:　每一条JVM线程都有自己的PC寄存器，用来控制线程的执行。<br>　<br>JVM Stack(JVM栈):　Stack里存放的是Frame(帧)（如下图所示）。　</p>
<p>Native Method Stack(本地方法栈):　用来支持native methods (非Java语言method)。　</p>
<h4 id="所有的线程共享数据区">所有的线程共享数据区</h4>
<p>所有的线程共享数据区有Heap和Method Area.</p>
<p>Heap(堆)是与我们平时编程最直接打交道的区域。它存放所有的对象和数组。在JVM启动时划分生成。常说的Garbage Collector垃圾回收器就是对这个区域工作的。　</p>
<p>Method Area(方法区)存储类的结构信息，包括 run-time constant pool, field and method data, 和methods and constructors代码。　</p>
<p>Runtime Constant Pool（运行时常量池）存放编译时可知的数值字面量和运行期解析后才能获得的method或field的引用。</p>
<p><img src="http://xumyselfcn.github.io/imgs/JVM-Stack.png" alt=""></p>
<p>Stack中的包含一些Frame, 这些Frame在method调动的时候生成。每一个Frame包括：local variable array, Operand Stack, Reference to Constant Pool.</p>
<h2 id="另一种JVM运行时数据区划分">另一种JVM运行时数据区划分</h2>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>堆</li>
<li>方法区</li>
</ul>
<h3 id="程序计数器">程序计数器</h3>
<p>小内存空间，是当前线程所执行的字节码的行号指示器。</p>
<p>在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器。</p>
<p>Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的。每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储。这类内存区域是<code>线程私有</code>的。</p>
<h3 id="Java虚拟机栈">Java虚拟机栈</h3>
<p>同程序计数器一样，Java虚拟机栈一手线程私有的，其生命周期与线程相同。</p>
<p>每个方法被执行的时候，都会同时创建一个栈帧，用于存储局部变量表、操作栈、动态链接、方法出口等信息。每个方法被调用直至完成的过程，就对应着有一个栈帧在虚拟机中入栈到出栈的过程。</p>
<p>关于局部变量表：存放各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（从c指针的角度来说就是一个指针，指向存放该对象的内存区域）和returnAddress类型（指向一条字节码指令的地址）。</p>
<p>局部变量表所需的内存空间在编译期间完成分配。运行期间也不会改变。</p>
<p>本区域的异常：</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常</li>
<li>如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</li>
</ul>
<h3 id="本地方法栈">本地方法栈</h3>
<p>与虚拟机栈发挥的作用类似，虚拟机栈为虚拟机执行Java方法服务，本地方法栈为虚拟机执行Native方法服务。</p>
<p>异常方面：也会抛出OutOfMemoryError、OutOfMemoryError异常。</p>
<h3 id="Java堆">Java堆</h3>
<p>所有线程共享，唯一目的是存放对象实例。</p>
<ul>
<li>Java堆是垃圾收集器管理的主要区域。</li>
<li>Java堆可以处于物理上不连续的内存空间，但逻辑上是连续的。</li>
<li>堆的大小扩展，如果在堆中没有内存空间进行实例分配，且堆已经扩展到最大时，会抛出OutOfMemoryError异常。</li>
</ul>
<h3 id="方法区">方法区</h3>
<p>同样是所有线程共享，存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>当方法区无法满足内存分配需求时，抛出OutOfMemoryError异常。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>周志明 《深入理解Java虚拟机》第二章</li>
<li><a href="http://www.programcreek.com/2013/04/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/" target="_blank" rel="external">JVM运行时是什么样子</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一种JVM运行时数据区划分">一种JVM运行时数据区划分</h2>
<p><img src="http://xumyselfcn.github.io/imgs/JVM-runtime-data-area.jpg" alt=""></p>
<p>（图片来源：<a h]]>
    </summary>
    
      <category term="Java" scheme="http://blog.xumingyang.cn/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Scala的三个特殊类型Nothing、Any、Option]]></title>
    <link href="http://blog.xumingyang.cn/2014/03/19/wiki/Scala%E8%87%AA%E9%80%82%E5%BA%94%E7%B1%BB%E5%9E%8B/"/>
    <id>http://blog.xumingyang.cn/2014/03/19/wiki/Scala自适应类型/</id>
    <published>2014-03-19T14:17:16.000Z</published>
    <updated>2015-04-08T06:11:18.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Scala的三个特殊类型Nothing、Any、Option">Scala的三个特殊类型Nothing、Any、Option</h2>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util._</div><div class="line"></div><div class="line"><span class="keyword">var</span> list1 : List[Int] = <span class="keyword">new</span> ArrayList[Int]</div><div class="line"><span class="keyword">var</span> list2 = <span class="keyword">new</span> ArrayList[Int]</div><div class="line"><span class="keyword">var</span> list3 = <span class="keyword">new</span> ArrayList[Any]	</div><div class="line"></div><div class="line"><span class="keyword">var</span> ref1 : Int = <span class="number">1</span></div><div class="line"><span class="keyword">var</span> ref2 : Any = <span class="keyword">null</span></div><div class="line"></div><div class="line">list2 add <span class="number">1</span></div><div class="line">list2 add <span class="number">2</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> total = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">val</span> index &lt;- <span class="number">0</span> until list2.size())</div><div class="line">{</div><div class="line">	total += list2.get(index)</div><div class="line">}</div><div class="line"></div><div class="line">println(<span class="string">"total is: "</span>+total)</div></pre></td></tr></table></figure>

<p>解释一下上面的代码：</p>
<ul>
<li><p>import里面的下划线，等价于java里的 ( * ),该语句导入了java.util包中的所有的类。</p>
</li>
<li><p>创建list1引用，只想ArrayList[Int]的实例。然后创建另一个引用list2，指向为指导参数类型的ArrayList实例。<code>在幕后，Scala实际上穿件了一个ArrayList[Nothing]</code>的实例。如果将list1赋给list2，则会编译报错。</p>
</li>
<li>默认情况下，Scala是不允许把一个持有任意类型实例的容器赋值给持有Any实例的容器。也就是若将list2赋值给list3，会发生编译错误。</li>
<li>ref1赋值给ref2可以通过编译，这个等价于将Integer引用赋给一个Object类型的引用。</li>
</ul>
<h3 id="Nothing类型">Nothing类型</h3>
<p>在Scala中Nothing是所有类的子类。Scala把new ArrayList 当做ArrayList[Nothing]这样的实例。基类实例是不能当做派生类实例，Nothing是最底层的子类。</p>
<p>Scala使用Nothing——所有类型的子类——帮助类型推演更平滑的进行。既然他是任何类的子类，他就可以替换任何东西。Nothing是抽象的，在运行时，他的实例并不会真实存在，纯粹就是类型推演的帮手。</p>
<h3 id="Any类型">Any类型</h3>
<p>Any是所有Scala类型的超类。Any可以持有任何类型对象的引用。Any是抽象类，有如下的方法： !=() 、 ==() 、 asInstanceOf() 、 equals() 、 hashCode() 、 isInstanceOf() 和 toString()。</p>
<p>Any的直接后代是<strong>AnyVal</strong>和<strong>AnyRef</strong>。</p>
<ul>
<li>AnyVal是所有可以映射为Java基本类型（比如Int，Double等）的Scala类型的基类。</li>
<li>AnyRef是所有引用类型的基类。</li>
</ul>
<p><strong>AnyRef</strong>直接映射为Java的Object，在Scala中使用它，就如同在Java里使用Object一样。</p>
<p><strong>Any</strong>或<strong>AnyVal</strong>在编译成字节码时，Scala也会在内部把他们当做Object的引用处理。Object的某些方法也不能通过Any或AnyVal的引用来调用。</p>
<h3 id="Option类型">Option类型</h3>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> commentOnPractice(input: String) = {</div><div class="line">	<span class="comment">//rather than returning null</span></div><div class="line">	<span class="keyword">if</span>(input == <span class="string">"test"</span>) Some (<span class="string">"good"</span>) <span class="keyword">else</span> None</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span>(input &lt;- Set(<span class="string">"test"</span>,<span class="string">"hack"</span>)){</div><div class="line">	<span class="keyword">val</span> comment = commentOnPractice(input)</div><div class="line">	println(<span class="string">"input "</span> + input +<span class="string">" comment "</span>+comment.getOrElse(<span class="string">"Found no comments"</span>))</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码输出如下：</p>
<blockquote>
<p>input test comment good</p>
<p>input hack comment Found no comments</p>
</blockquote>
<ul>
<li>这里，commentOnPractice()也许会返回一个注释（String），也许压根没有注释，这两点分别用Some[T]和None的实例表示。这两个类都集成Option[T]。</li>
<li>调用返回Option[T]的getOrElse()方法，可以主动的应对结果不存在(None)的情形。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Scala的三个特殊类型Nothing、Any、Option">Scala的三个特殊类型Nothing、Any、Option</h2>
<figure class="highlight scala"><table><tr><td class="gutter"><p]]>
    </summary>
    
      <category term="Scala" scheme="http://blog.xumingyang.cn/categories/Scala/"/>
    
  </entry>
  
</feed>
